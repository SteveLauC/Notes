> 上一节课我们讲了bootset，计算机执行是取址执行，然而操作系统是在磁盘里面的，所以想要进行取址，必须将操作系统加载到内存中去，bootsector做的就是这个，将setup4个扇区和system扇区加载到内存中去。



### setup模块作用

它完成的是os启动前的设置。

setup做的第一件事就是确定pc的内存到底有多大，方便os管理内存。然后将操作系统在内存中移动到0内存处，最后进入保护模式，保护模式就是32位模式，为什么要到32位，16位的寄存器左移4位是20位，20位的寻址能力只有1M，不足以对当今计算机4G内存进行操作，所以需要到32位寻址模式下也就是保护模式。

> 有一个很酷的寄存器，cr0，它的最后一位如果是0的话，就是实模式，如果是1的话就是保护模型。

 在保护模式下的寻址不再是cs左移4位+IP，而是根据cs查表+IP，由于cs是表中的一项，cs就有了一个新的名字「选择子」。这个表就是GDT(global descriptor table)，表是由setup创建的。按照gdt表会跳转到0地址处，开始对操作系统进行取址执行了。

> 简单回顾下setup做的事情，首先对硬件进行了熟悉，然后将操作系统在内存中移动到0地址处，然后启动32位模式，保护模式，最后查表跳到0地址处对操作系统的代码进行执行。



### system模块

system模块的第一个代码是head.s，head.s里面的汇编和bootset/setup里面的汇编不一样，后者是16位的汇编，前者是32位的汇编。在head.s中调用main.c，main.c是一个函数，主要对硬件进行初始化。我们从中选1个，mem_init来看一下，此函数就是初始化内存，有一个mem_map内存表/数组，为0的话表示内存没有被使用



### 总结

boot是将setup/system加载到内存中，setup是在os跑起来前做一些初始化，转入了保护模式，创建了GDT这个表，system模块里的head跳到了main.c，main函数对硬件进行了初始化。

其实，无非就做了两件事情：

1. 将操作系统读入内存中，为了取址执行
2. 初始化操作系统