> This chapter is about:
>
> * Before I read it
>   
>   A very basic introduction to non-function pointer fields of the `struct IndexAmRoutine`
>
> * After I read it
>   * ...

> What do you expect to learn from it (fill in this before reading it)
>
> * If you are new to it, ...
>
>   * The meaning of the fields and fuctions defined in `struct IndexAmRoutine`
>   * Perhaps something to note when writing your custom index AM?
>
> * If you already knew something about it, ... 
>   > tip: think more and read less in this case

> What have you learned from it
>
> *
> *

1. Every access method (regardless of its type) has an entry in system 
   catalog `pg_am`:
   
   ```sql
   steve=# select * from pg_am;
    oid  | amname |      amhandler       | amtype
   ------+--------+----------------------+--------
       2 | heap   | heap_tableam_handler | t
     403 | btree  | bthandler            | i
     405 | hash   | hashhandler          | i
     783 | gist   | gisthandler          | i
    2742 | gin    | ginhandler           | i
    4000 | spgist | spghandler           | i
    3580 | brin   | brinhandler          | i
   (7 rows)
   ```
   
   An entry contains:
   
   * name: the name of the AM
   * handler: a function that returns the defined  `struct IndexAmRoutine`. 
     It will takes a dummy argument of type `internal` to prevent it from 
     being accidentially called in normal SQL. The returned struct has to
     be `palloc()`'d:
     
     In Rust, it will be typically like:
     
     ```rust
     #[pg_extern(sql = "
     CREATE FUNCTION bm25_handler(internal) RETURNS index_am_handler PARALLEL SAFE IMMUTABLE STRICT COST 0.0001 LANGUAGE c AS 'MODULE_PATHNAME', '@FUNCTION_NAME@';
     CREATE ACCESS METHOD bm25 TYPE INDEX HANDLER bm25_handler;
     COMMENT ON ACCESS METHOD bm25 IS 'bm25 index access method';
     ")]
     fn bm25_handler(_fcinfo: pg_sys::FunctionCallInfo) -> PgBox<pg_sys::IndexAmRoutine> 
     ```
     
     
   * type: it is a table or an index
   
2. The non-pointer type fields of `struct IndexAmRoutine`

   * `NodeTag type`: has to be `NodeTag::T_IndexAmRoutine`
   
     > Emm, interesting, if the value is fixed, then why do we need to specify it.
     >
     > Possible answer, I guess it will be type-erased.
     
   * `uint16 amstrategies`: Total number of strategies (operators) by which we
     can traverse/search this AM. Zero if AM does not have a fixed set of strategies 
     assignments.
     
     > QUES: If I have mutliple OPERATOR CLASSes specified for this index am, 
     > then the value set in this field should be their operators' sum, right?
     
   * `uint16 amsupport`: total number of support functios that this AM uses. 
   
   * `uint16 amoptsprocnum`: opclass options support function number or 0.
   
     > QUES: what is this?
     
   * `bool amcanorder`: does AM support `ORDER BY` indexed column's value? 
   
     > QUES: what is this?
     
   * `bool amcanorderbyop`: does AM support `ORDER BY` result of an operator on
     indexed column. 
     
     > QUES: what is this and what's the difference between this and `amcanorder`?
     
   * `bool amcanbackward`: does AM support backward scanning?
   
   * `bool amcanunique`: does AM support `UNIQUE` indexes
   
      > QUES: what is this?
      >
      > I thought this sign indicates if this index can be used to deduplicate
      > data, then hash index can definitely be used for that, I checked hash
      > index's source code, but [this field is set to `false`][hash_canunique]
      >
      > [hash_canunique]: https://github.com/postgres/postgres/blob/2453196107de66cff0257feef2ff8585dcf9d924/src/backend/access/hash/hash.c#L67
      
   * `bool amcanmulticol`: does AM support multi-column indexes
   
   * `bool amoptionalkey`: does AM require scans to have a constraint on the first
     index column?
     
     > QUES: what is this?
     >
     > What does "constraint" mean here? "fist index column", so this is field
     > only makes sense if your index support multi-column scan?
     
   * `bool amsearcharray`: does AM handle `ScalarArrayOpExpr` quals?
   
     > `ScalarArrayOpExpr` refers to expressions like:
     >
     > 1. `item in array[]`
     > 2. `item = ANY(ARRAY[])`
     >
     > It is literally "searching" the `array` for `item`, so this field is called
     > `searcharray`.
     
     > `qual` means: 
     
   * `bool`  