> This section introduces the page format used by Postgres table and index. Sequence
> and TOAST tables also use this format.
>
> Sequence tables are tables for sequence generators.

> In the following note, an item of a page refers a data entry stored in the page,
> for a heap page (table page), an item refers to a tuple. For an index page, an
> item is an index entry (key and ctid pair).

1. The default page size is 8Kb, you cannot change it unless you re-compile it
   from the source code.

   [How to change/set the block size in Postgres? Is there any file to make the configuration?](https://stackoverflow.com/q/56147727/14092446)


3. In Postgres, all the heap pages are logically equivalent, so a tuple can be
   stored in any page (heap file organization). SQLite is different, it uses a
   B-Tree to organize pages, though they all use slotted pages.

   For index pages, the first page is generally reserved as a meta page holding 
   control information. And there can be different kinds of pages within the
   index, depending on the index access method.

4. Overall Page Layout

   > For table: heap file organization and slotted pages
   >
   > For B-tree index: (I guess) B+Tree and slotted pages

   | Item | Description| 
   |------|------------|
   |PageHeaderData | 24 bytes long, contains general infornation about the page, including 2 free space pointers|
   |ItemIdData | Array of item identifiers pointing to the actual items, each entry is an (offset, len) pair, 4 bytes per item |
   |FreeSpace | The unallocated space, new ItemID will be allocated from the start, item from the end |
   |Items | The actual items (tuples) |
   |Special space | Index method specific data, empty for table pages |

   ![diagram](https://github.com/SteveLauC/pic/blob/main/Screenshot%20from%202024-03-18%2008-24-47.png)

   > Code `struct ItemIdData`:
   >
   > ```c
   > /*
   > * A line pointer on a buffer page.  See buffer page definitions and comments
   > * for an explanation of how line pointers are used.
   > *
   > * In some cases a line pointer is "in use" but does not have any associated
   > * storage on the page.  By convention, lp_len == 0 in every line pointer
   > * that does not have storage, independently of its lp_flags state.
   > */
   > typedef struct ItemIdData
   > {
   > unsigned	lp_off:15,		/* offset to tuple (from start of page) */
   >           lp_flags:2,		/* state of line pointer, see below */
   >           lp_len:15;		/* byte length of tuple */
   > } ItemIdData;
   > ``` 


5. PageHeaderLayout

   | Field | Type | Len | Description |
   |-------|------|-----|-------------|
   | pd_lsn | PageXLogRecPtr | 8 bytes | LSN: next byte after last byte of WAL record for last (latest) change to this page |
   | pd_checksum | uint16 | 2 bytes | Page checksum if `data checksums` are enabled (`SHOW data_checksum`) or it will all 0s |
   | pd_flags | uint16 | 2 bytes | flag bits |
   | pd_lower | LocationIndex (alias to uint16) | 2 bytes | offset to start of free space |
   | pd_upper | LocationIndex (alias to uint16) | 2 bytes | offset to end of free space |
   | pd_special | LocationIndex (alias to uint16) | 2 bytes | offset to start of special space (8192 if this is a table page) |
   | pd_page_size_version | uint16 | 2 bytes | Page size and layout version number (On a little endian machine, the first byte is the page version, the second byte is page size, starting from Pg 8.3, page version is 4) |
   | pd_prune_xid | TransactionId (alias to uint32) | 4 bytes | Oldest unpruned XMAX on page, or zero if none |

   The `pd_page_size` field is simply for check purpose, PostgreSQL does not 
   support having different page sizes for different tables, and to change the
   page size, one have to rebuild the binary.

6. Encoding of the `PageXLogRecPtr` type

   ```c
   /*
   * For historical reasons, the 64-bit LSN value is stored as two 32-bit
   * values.
   */
   typedef struct
   {
      uint32		xlogid;			/* high bits */
      uint32		xrecoff;		/* low bits */
   } PageXLogRecPtr;
   ```

   ```
   | wal file ID (32 bits) | segment number (8bits) | block number (13bits) |offset within the block (11bits) |
   ```


7. The field `ctid`, is the number of `(page ID, idx of ItemID)`.

8. Tuple layout

   * header
   * NULL bitmap
   * tuple data
