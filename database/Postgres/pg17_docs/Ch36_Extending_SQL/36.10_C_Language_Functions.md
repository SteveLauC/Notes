> * 36.10.1. Dynamic Loading  
> * 36.10.2. Base Types in C-Language Functions  
> * 36.10.3. Version 1 Calling Conventions  
> * 36.10.4. Writing Code  
> * 36.10.5. Compiling and Linking Dynamically-Loaded Functions  
> * 36.10.6. Composite-Type Arguments  
> * 36.10.7. Returning Rows (Composite Types)  
> * 36.10.8. Returning Sets  
> * 36.10.9. Polymorphic Arguments and Return Types  
> * 36.10.10. Shared Memory  
> * 36.10.11. LWLocks  
> * 36.10.12. Custom Wait Events  
> * 36.10.13. Injection Points  
> * 36.10.14. Using C++ for Extensibility  


# 36.10.1. Dynamic Loading  

1. The first time a C function gets called/invoked, Postgres/dynamic loader 
   loads the shared object file that contains this function to the memory.

   In order to make this work, extension developers have to provide 2 arguments
   when writing `CREATE FUNCTION` in the extension SQL script:

   1. Path to the shared object that contains the function
 
      It can be:

      * an absolute path 
      * Path under `$libdir`, e.g., `$libdir/heap_tuple_summary`, Postgres will 
        replace `$libdir` with `$(pg_config --pkglibdir)`.

        > Shoot, this is so confusing. `libdir` and `pkglibdir` are 2 different
        > locations.
        >
        > https://www.postgresql.org/message-id/Pine.LNX.4.56.0307310942260.1729%40krusty.credativ.de
        
      * If the name does not contain a directory part, the file is searched for 
        in the path specified by the configuration variable `dynamic_library_path`.

        > `dynamic_library_path` is a configuration entry in `postgres.conf`

      If the above lookup procedure fails, Postgres will append a `.so` (`.dylib` on 
      macOS) extension to the `obj_file`, then search for it again.

   2. Name of C function, which is optional, SQL function name will be used 
      instead if it is not supplied.

      Thus, if your C function and SQL function have the same name, you can omit
      this parameter.

   > From doc of `CREATE FUNCTION`:
   >
   > https://www.postgresql.org/docs/current/sql-createfunction.html
   > 
   >  # obj_file, link_symbol
   >
   > This form of the `AS` clause is used for dynamically loadable C language 
   > functions when the function name in the C language source code is not the 
   > same as the name of the SQL function. The string `obj_file` is the name of 
   > the shared library file containing the compiled C function, and is interpreted 
   > as for the LOAD command. 
   >
   > The string `link_symbol` is the function's link symbol, that is, the name 
   > of the function in the C language source code. If the link symbol is omitted, 
   > it is assumed to be the same as the name of the SQL function being defined. 
   > The C names of all functions must be different, so you must give overloaded C 
   > functions different C names (for example, use the argument types as part of 
   > the C names).
   >
   > When repeated `CREATE FUNCTION` calls refer to the same object file, the file 
   > is only loaded once per session. To unload and reload the file (perhaps 
   > during development), start a new session.

2. "magic block" to prevent incompatibility

   To ensure that a dynamically loaded object file is not loaded into an 
   incompatible server, PostgreSQL checks that the file contains a 
   “magic block” with the appropriate contents. This allows the server to 
   detect obvious incompatibilities, such as code compiled for a different 
   major version of PostgreSQL. To include a magic block, write this in 
   one (and only one) of the module source files, after having included the 
   header `fmgr.h`:

   ```c
   PG_MODULE_MAGIC;
   ```

3. There is currently no way to unload a loaded shared object unless you re-open a
   new session.

4. Every dynamic shared object can have an init function:

   ```c
   void _PG_init() {
       /* impl here */
   }
   ```

   It will be called immediately when the object file gets loaded


# 36.10.2. Base Types in C-Language Functions 

1. There are 3 kinds of types:

   1. pass by value, fixed-length
   
      The maximum size of this kind is the pointer size.
   
   2. pass by reference, fixed-length
   
      ```c
      /* 16-byte structure, passed by reference */
      typedef struct
      {
          double  x, y;
      } PointData;
      
      typedef PointData * Pointer;
      ```
   
   3. pass by reference, variable-length
   
      It is required that the first 4 bytes (first field, C compiler won't 
      reorder fields) should be the **total** length of  this variable type 
      (including the 4 bytes). For example, here is how the `Vector` type 
      gets defined in `pgvector`:
   
      ```c
      typedef struct Vector
      {
       	int32		vl_len_;		/* varlena header (do not touch directly!) */
       	int16		dim;			/* number of dimensions */
       	int16		unused;			/* reserved for future use, always zero */
       	float		x[FLEXIBLE_ARRAY_MEMBER];
      }	Vector;
      ```
      
      These 4 bytes should not be modified manually, we should always set it via
      the `SET_VARSIZE` macro.
      
      There is a constant `VARHDRSZ` to represent the varlen header size.
      

2. PostgreSQL SQL Type to C Type Mapping, and their types

   | SQL Type | C Type | Defined In | type |
   | --- | --- | --- | --- |
   | `boolean` | `bool` | `postgres.h` (or compiler built-in) | fixed-size, pass by value |
   | `box` | `BOX*` | `utils/geo_decls.h` | fixed-size, pass by reference |
   | `bytea` | `bytea*` | `postgres.h` | var-len, pass by reference |
   | `"char"` | `char` | (compiler built-in) | fixed-size, pass by value |
   | `character` | `BpChar*` | `postgres.h` | var-len, pass by reference |
   | `cid` | `CommandId` | `postgres.h` | fixed-size, pass by value |
   | `date` | `DateADT` | `utils/date.h` | fixed-size, pass by value |
   | `float4` (real) | `float4` | `postgres.h` | fixed-size, pass by value |
   | `float8` (double precision) | `float8` | `postgres.h` | fixed-size, pass by value |
   | `int2` (smallint) | `int16` | `postgres.h` | fixed-size, pass by value |
   | `int4` (integer) | `int32` | `postgres.h` | fixed-size, pass by value |
   | `int8` (bigint) | `int64` | `postgres.h` | fixed-size, pass by value |
   | `interval` | `Interval*` | `datatype/timestamp.h` | fixed-size, pass by reference |
   | `lseg` | `LSEG*` | `utils/geo_decls.h` | fixed-size, pass by reference |
   | `name` | `Name` | `postgres.h` | fixed-size, pass by reference |
   | `numeric` | `Numeric` | `utils/numeric.h` | var-len, pass by reference |
   | `oid` | `Oid` | `postgres.h` | fixed-size, pass by value |
   | `oidvector` | `oidvector*` | `postgres.h` | var-len, pass by reference |
   | `path` | `PATH*` | `utils/geo_decls.h` | var-len, pass by ref |
   | `point` | `POINT*` | `utils/geo_decls.h` | not found this type |
   | `regproc` | `RegProcedure` | `postgres.h` | fixed-size, pass by value |
   | `text` | `text*` | `postgres.h` | var-len, ref |
   | `tid` | `ItemPointer` | `storage/itemptr.h` | fixed-size, pass by ref |
   | `time` | `TimeADT` | `utils/date.h` | fixed-size, value |
   | `time with time zone` | `TimeTzADT` | `utils/date.h` | fixed-size, pass by ref |
   | `timestamp` | `Timestamp` | `datatype/timestamp.h` | fixed-size, pass by value |
   | `timestamp with time zone` | `TimestampTz` | `datatype/timestamp.h` | fixed-size, pass by value |
   | `varchar` | `VarChar*` | `postgres.h` |var-len, ref |
   | `xid` | `TransactionId` | `postgres.h` | fixed-size, value |
   

# 36.10.3. Version 1 Calling Conventions 

> This is currently the only calling convention Postgres has

1. Function signature

   Public (by pub, I mean it will be exposed and loaded by Postgres) C functions 
   should be declared in this way if you follow this convention:
   
   ```c
   Datum your_func(PG_FUNCTION_ARGS);
   ```
   
   And you should write this macro `PG_FUNCTION_INFO_V1(your_func);` right before 
   this funtion, so:
   
   
   ```c
   PG_FUNCTION_INFO_V1(your_func);
   Datum your_func(PG_FUNCTION_ARGS) {
       /* impl */
   }
   ```
   
   Real-world example:
   
   ```c
   PG_FUNCTION_INFO_V1(add_one);
   Datum
   add_one(PG_FUNCTION_ARGS)
   {
       int32   arg = PG_GETARG_INT32(0);
   
       PG_RETURN_INT32(arg + 1);
   }
   ```
   
2. Extract arguments 

   You can extract the arguments using any above macro. Be sure that the argument
   is NOT null, then invoke the macro. You can check this using `PG_ARGISNULL()`. 
   Or this can be omitted if the function is declared as `STRICT` (NULL input 
   results in NULL output, Postgres handles  this for you automatically).

   * `PG_GETARG_<type>(arg_idx_num)`

   * `PG_GETARG_<type>_COPY(arg_idx_num)`
  
      This would return a copy of the argument so that you can safely write to it. 
      
      Other macros will sometimes return a pointer to a value that is physically 
      stored in a table (memory buffer), which must not be written to.
      
   * `PG_GETARG_xxx_SLICE(arg_idx_num, offset, length)` 
   
     Only ask for the data specified by `[offset, offset+length)`.
     
     `length` can be negative, any negative value means asking for all the 
     remaining bytes starting from `offset`.
   
3. To return a value
   
   And the return value should be returned using `PG_RETURN_<type>()`. To return 
   NULL, use `PG_RETURN_NULL()`.
   
# 36.10.4. Writing Code
   
1. > Always zero the bytes of your structures using memset (or allocate them 
   with palloc0 in the first place). Even if you assign to each field of your 
   structure, there might be alignment padding (holes in the structure) that 
   contain garbage values. Without this, it's difficult to support hash indexes 
   or hash joins, as you must pick out only the significant bits of your data 
   structure to compute a hash. The planner also sometimes relies on comparing 
   constants via bitwise equality, so you can get undesirable planning results 
   if logically-equivalent values aren't bitwise equal.
   
   
   TIL that Rus# t won't not zero padding as well!
   
# 36.10.6. Composite-Type Arguments
# 36.10.7. Returning Rows (Composite Types)