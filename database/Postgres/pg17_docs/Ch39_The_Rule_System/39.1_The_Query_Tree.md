# Components of a Query tree (struct Query)

* commandType: type of command (select/update/insert/delete/merge/utility)

* querySource: where did this querytree come from? Typically, there are 2 sources
  of `struct Query`s:

  1. Original query
  2. Created by the Rule/Rewriter

  Then for the ones created by the rewriter, it can be categorized into:

  ```c
	QSRC_INSTEAD_RULE: 1			  /* added by unconditional INSTEAD rule */
	QSRC_QUAL_INSTEAD_RULE: 2		/* added by conditional INSTEAD rule */
	QSRC_NON_INSTEAD_RULE: 3		/* added by non-INSTEAD rule */
  ```

* queryId: unique identifier for a query

* canSetTag: In PG protocol, when a query is complete, Postgres server (the backend)
  will set a command tag to indicate the completion, and expose some information.

  > https://www.postgresql.org/docs/current/protocol-message-formats.html
  >
  > The command tag. This is usually a single word that identifies which SQL 
  > command was completed. 

  A single user query can be rewritten to multiple querytrees, one of which needs to
  set this command tag.  This field specifies if the current `struct Query` would do
  that.

* utilityStmt: If this query is a utility command, this field is a pointer to 
  a utility statement.  Otherwise, it is NULL.

* resultRelation (RT index, int): the table to which the query result will go. 
  Identified by the index number in the range table list. 0 for `SELECT` statements.

* hasAggs: If this query contains aggregations in target list or having clause

  ```sql
  SELECT city, count(*), max(temp_lo)
  FROM weather
  GROUP BY city
  HAVING max(temp_lo) < 40;
  ```

  `max(temp_lo)` appears in both target list and having clause

* hasWindowFuncs: if this query contains window functions in the target list

* hasTargetSRF: if this query contains set-returning function

  > SRF: is postgres functions that could return multiple rows.
  >
  > See database/Postgres/pg17_docs/Ch36_Extending_SQL/36.10_C_Language_Functions.md

* hasSubLinks: if this query contains sublinks

* hasDistinctOn: if this query contains `DISTINCT ON` (NOT `DISTINCT`)

  ```sql
  -- Different from DISTINCT, this Only ensures uniqueness on column "name" 
  SELECT DISTINCT ON (name) name, subject, score
  FROM student_scores
  ORDER BY name, score DESC;
  ```

* hasRecursive: if SQL contains `WITH RECURSIVE`

  ```sql
  WITH RECURSIVE cte_table (id) 
  AS ( SELECT id FROM foo)
  SELECT * FROM cte_table;
  ```

* hasModifyingCTE: True if this query contains CTE and the CTE query modifies 
  something

  ```sql
  WITH RECURSIVE cte_procedure 
  -- See this RETURNING clause, it returns the newly-inserted id value, and we 
  -- can select from it!
  AS (INSERT INTO foo VALUES (99) RETURNING id) 
  SELECT * FROM cte_procedure;
  ```

* hasForUpdate: Whether this SQL contains `FOR UPDATE` or `FOR SHARE`


  > https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS

* hasRowSecurity: rewriter has applied some row-level security policy 

  > https://www.postgresql.org/docs/current/ddl-rowsecurity.html

* hasGroupRTE: if this query contains a RTE_GROUP range table entry

* isReturn: For PL/pgSQL, if this query is a `RETURN` statement. Should always be 
  false for plain SQL.

* cteList (List<CommonTableExpr>): list of common table expressions:

  ```sql
  with recursive 
    cte1 as ()
    cte2 as ()
    cte3 as ()
  ```

* rtable (List<RangeTblEntry>): a list of relations used in the query.  For `SELECT`, these are 
  relations after the `FROM` keyword.

  Only **explicit JOIN syntax** produces a join RTE, not the implicit join resulting from multiple 
  FROM items.  This is because we only need the RTE to deal with SQL features like "outer joins"
  and "join-output-column aliasing". And, `MERGE` command produces `RTE_JOIN` as well. 

  > QUES: I currently don't understand the reason explained above.

* rteperminfos: list of RTEPermissionInfo nodes for the rtable entries having
	perminfoindex > 0

  > List<RTEPermissionInfo>

* jointree (FromExpr): 
  
  * table join tree (FROM and WHERE clauses); 
  * also source relation when it is a `MERGE` command, the `FromExpr.fromlist` 
    will have only 1 element, it could be of type `RangeTblRef` or `JoinExpr`. 
    See `transform_MERGE_to_join(parse)`. `FromExpr.quals` will be qualifications
    on the **TARGET result** (not source relation), if target relation is an
    auto-updatable view.

  Difference between `rtable` and `jointree`: rTable is a flat structure that stores
  all the relations invoked, `jointree` references those table entries stored in
  `rtable` using RT indexes.

  A table can appear multiple times in a query, by splitting it and its reference/usage,
  we can only store it once (in `rtable`) and reference it for multiple times.

* mergeActionList (List<MergeAction>): Only set for `MERGE` command, list of actions for `MERGE`

  ```sql
  postgres=# select * from foo;
  id | description 
  ----+-------------
    1 | one
  (1 row)

  postgres=# select * from bar;
  id | description 
  ----+-------------
    1 | 一
    2 | 二
  (2 rows)

  postgres=*# merge into foo 
  postgres-*# using bar
  postgres-*# on foo.id=bar.id
  postgres-*# when matched then
  postgres-*#   update set description = bar.description
  postgres-*# when not matched then
  postgres-*#   insert (id, description) values (bar.id, bar.description);
  ```

  ```text
  :mergeActionList (
    {MERGEACTION 
    :matchKind 0 
    :commandType 2 
    :override 0 
    :qual <> 
    :targetList (
        {TARGETENTRY 
        :expr 
          {VAR 
          :varno 2 
          :varattno 2 
          :vartype 25 
          :vartypmod -1 
          :varcollid 100 
          :varnullingrels (b)
          :varlevelsup 0 
          :varreturningtype 0 
          :varnosyn 2 
          :varattnosyn 2 
          :location 87
          }
        :resno 2 
        :resname description 
        :ressortgroupref 0 
        :resorigtbl 0 
        :resorigcol 0 
        :resjunk false
        }
    )
    :updateColnos <>
    }
    {MERGEACTION 
    :matchKind 2 
    :commandType 3 
    :override 0 
    :qual <> 
    :targetList (
        {TARGETENTRY 
        :expr 
          {VAR 
          :varno 2 
          :varattno 1 
          :vartype 23 
          :vartypmod -1 
          :varcollid 0 
          :varnullingrels (b)
          :varlevelsup 0 
          :varreturningtype 0 
          :varnosyn 2 
          :varattnosyn 1 
          :location 160
          }
        :resno 1 
        :resname id 
        :ressortgroupref 0 
        :resorigtbl 0 
        :resorigcol 0 
        :resjunk false
        }
        {TARGETENTRY 
        :expr 
          {VAR 
          :varno 2 
          :varattno 2 
          :vartype 25 
          :vartypmod -1 
          :varcollid 100 
          :varnullingrels (b)
          :varlevelsup 0 
          :varreturningtype 0 
          :varnosyn 2 
          :varattnosyn 2 
          :location 168
          }
        :resno 2 
        :resname description 
        :ressortgroupref 0 
        :resorigtbl 0 
        :resorigcol 0 
        :resjunk false
        }
    )
    :updateColnos <>
    }
  )
  ```

 


* mergeTargetRelation (int): Range table index to the merge target relation.

  Only set for MERGE query.
  
  > Where is source relation stored? It is stored in `jointree`
  
  If target relation is a regular table, then `mergeTargetRelation` has the
  same value as `resultRelation`. If target relation is a trigger-updatable
  view, then it will be the expanded view subquery that we need to pull data
  from.

* mergeJoinCondition: Only set for `Merge` command, NULL otherwise.  

  > type: Expr or subtype, like BooleanExpr

* targetList: a list of expr that define the query result

  > List<TargetEntry>
  
  * For SELECT: projection, `*` is a special abbreviation that will be expaned
    by the analyzer.
    
    ```c
    /*
     * transformTargetList()
     * Turns a list of ResTarget's into a list of TargetEntry's.
     *
     * This code acts mostly the same for SELECT, UPDATE, or RETURNING lists;
     * the main thing is to transform the given expressions (the "val" fields).
     * The exprKind parameter distinguishes these cases when necessary.
     */
    List *
    transformTargetList(ParseState *pstate, List *targetlist,
					ParseExprKind exprKind)
    ```
    
  * INSERT 
  * DELETE
  * UPDATE

* override: If this query contains a `OVERRIDING` clause. If so, what is its kind:

  * OVERRIDING_USER_VALUE,
	* OVERRIDING_SYSTEM_VALUE,

  ```sql
  INSERT INTO my_table (id, name) 
  OVERRIDING SYSTEM VALUE 
  VALUES (1, 'Alice');
  ```

* onConflict: If the SQL is an `INSERT` and contains an `ON CONFLICT DO` clause, this 
  field stores that clause.

  > Postgres does not support `UPSERT` before 15, `ON CONFLICT DO` is an alternative 
  > to that

* returningOldAlias
* returningNewAlias
* returningList

* groupClause: `GROUP BY` clause

* groupDistinct: QUES: I am not sure about this
* groupingSets: QUES: I am not sure about this


* havingQual (List<Node>, too generic?): `HAVING` clause

* windowClause

* distinctClause: DISTINCT or DISTINCT ON clause

* sortClause: ORDER BY

* limitOffset: OFFSET X

* limitCount: LIMIT x

* limitOption

* rowMarks: (could be wrong) a mechanism to implement row-level locks

* setOperations: set-operation tree if this is top level of a UNION/INTERSECT/EXCEPT query 

* constraintDeps: 

* withCheckOptions (List<WithCheckOption>): This field will be initialized by 
  the rewriter. It can be 2 things:

  1. `WITH CHECK OPTION` checks that will be applied to new tuples when inserting
     or updating an auto-updatable view
     
     ```c
     typedef enum WCOKind
     {
         WCO_VIEW_CHECK,				/* WCO on an auto-updatable view */

         // ...
     } WCOKind;
     ```

     ```sql
     create table numbers (num int, is_positive bool);
     create view positive_numbers as (select * from numbers where is_positive) WITH CHECK OPTION;

     -- Since this field will be populated by the rewriter, you have to use this option
     set debug_print_rewritten = true;
     insert into positive_numbers values (-1, false);
     ERROR:  new row violates check option for view "positive_numbers"
     :withCheckOptions (
       {WITHCHECKOPTION 
          :kind 0 
          :relname positive_numbers 
          :polname <> 
          :qual 
              {VAR 
              :varno 2 
              :varattno 2 
              :vartype 16 
              :vartypmod -1 
              :varcollid 0 
              :varnullingrels (b)
              :varlevelsup 0 
              :varreturningtype 0 
              :varnosyn 2 
              :varattnosyn 2 
              :location -1
              }
          :cascaded true
       }
     )
     ```
 
     It rejects writes that do not satisfy the qualification. For a view without 
     this `WITH CHECK OPTION`, these writes will be accepted, but you won't see
     these tuples in `select * from positive_number_without_with_check_option`
     since they do not satisfy the option.
      

  2. `RLS WITH CHECK` policies to be applied when inserting/updating a relation 
     with RLS (row-level security).

     ```c
     typedef enum WCOKind
     {
        // ...

        WCO_RLS_INSERT_CHECK,		/* RLS INSERT WITH CHECK policy */
        WCO_RLS_UPDATE_CHECK,		/* RLS UPDATE WITH CHECK policy */
        WCO_RLS_CONFLICT_CHECK,		/* RLS ON CONFLICT DO UPDATE USING policy */
        WCO_RLS_MERGE_UPDATE_CHECK, /* RLS MERGE UPDATE USING policy */
        WCO_RLS_MERGE_DELETE_CHECK, /* RLS MERGE DELETE USING policy */
     } WCOKind;
     ```

* stmt_location: start offset of the statement in the SQL string
* stmt_len: len of this statement