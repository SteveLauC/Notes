# Components of a Query tree (struct Query)

* commandType: type of command (select/update/insert/delete/merge/utility)

* querySource: where did this querytree come from? Typically, there are 2 sources
  of `struct Query`s:

  1. Original query
  2. Created by the Rule/Rewriter

  Then for the ones created by the rewriter, it can be categorized into:

  ```c
	QSRC_INSTEAD_RULE: 1			  /* added by unconditional INSTEAD rule */
	QSRC_QUAL_INSTEAD_RULE: 2		/* added by conditional INSTEAD rule */
	QSRC_NON_INSTEAD_RULE: 3		/* added by non-INSTEAD rule */
  ```

* queryId: unique identifier for a query

* canSetTag: In PG protocol, when a query is complete, Postgres server (the backend)
  will set a command tag to indicate the completion, and expose some information.

  > https://www.postgresql.org/docs/current/protocol-message-formats.html
  >
  > The command tag. This is usually a single word that identifies which SQL 
  > command was completed. 

  A single user query can be rewritten to multiple querytrees, one of which needs to
  set this command tag.  This field specifies if the current `struct Query` would do
  that.

* utilityStmt: If this query is a utility command, this field is a pointer to 
  a utility statement.  Otherwise, it is NULL.

* resultRelation (RT index, int): the table to which the query result will go. 
  Identified by the index number in the range table list. 0 for `SELECT` statements.
  
  This is also called target relation (when not talking about the `MERGE` command)

* hasAggs: If this query contains aggregations in target list or having clause

  ```sql
  SELECT city, count(*), max(temp_lo)
  FROM weather
  GROUP BY city
  HAVING max(temp_lo) < 40;
  ```

  `max(temp_lo)` appears in both target list and having clause

* hasWindowFuncs: if this query contains window functions in the target list

* hasTargetSRFs (bool): if this query contains set-returning function

  > SRF: is postgres functions that could return multiple rows.
  >
  > See database/Postgres/pg17_docs/Ch36_Extending_SQL/36.10_C_Language_Functions.md

* hasSubLinks (bool): if this query contains sublinks

  QUES: Since `pull_up_sublinks()` won't descend into subqueries, I highly doubt
  this flag only applies to the current `Query`. Gemini agrees with me.
  

* hasDistinctOn: if this query contains `DISTINCT ON` (NOT `DISTINCT`)

  ```sql
  -- Different from DISTINCT, this Only ensures uniqueness on column "name" 
  SELECT DISTINCT ON (name) name, subject, score
  FROM student_scores
  ORDER BY name, score DESC;
  ```

* hasRecursive: if SQL contains `WITH RECURSIVE`

  ```sql
  WITH RECURSIVE cte_table (id) 
  AS ( SELECT id FROM foo)
  SELECT * FROM cte_table;
  ```

* hasModifyingCTE: True if this query contains CTE and the CTE query modifies 
  something

  ```sql
  WITH RECURSIVE cte_procedure 
  -- See this RETURNING clause, it returns the newly-inserted id value, and we 
  -- can select from it!
  AS (INSERT INTO foo VALUES (99) RETURNING id) 
  SELECT * FROM cte_procedure;
  ```

* hasForUpdate (bool): Whether this query contains **explicit**

  1. `FOR UPDATE`
  2. `FOR NO KEY UPDATE`
  3. `FOR SHARE`
  4. `FOR KEY SHARE`
  
  in the **current** query level.
  
  > **explicit** means the SQL string contains these clauses. Postgres adds
  > `RowMarkClause`s for subqueries, these clauses are NOT explicit. See
  > the notes on `struct RowMarkClause`.
  
  See also:
  
  1. Notes on `struct RowMarkClause`
  2. "13.3_Explicit_Locking.md"
  3. https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS
  

* hasRowSecurity: rewriter has applied some row-level security policy 

  > https://www.postgresql.org/docs/current/ddl-rowsecurity.html

* hasGroupRTE: if this query contains a RTE_GROUP range table entry

* isReturn: For PL/pgSQL, if this query is a `RETURN` statement. Should always be 
  false for plain SQL.

* cteList (List<CommonTableExpr>): list of common table expressions:

  ```sql
  with recursive 
    cte1 as ()
    cte2 as ()
    cte3 as ()
  ```

* rtable (List<RangeTblEntry>): a list of relations used in the query.  For `SELECT`, these are 
  relations after the `FROM` keyword.

  Only **explicit JOIN syntax** produces a join RTE, not the implicit join resulting from multiple 
  FROM items.  This is because we only need the RTE to deal with SQL features like "outer joins"
  and "join-output-column aliasing". And, `MERGE` command produces `RTE_JOIN` as well. 

  > QUES: I currently don't understand the reason explained above.

* rteperminfos: list of RTEPermissionInfo nodes for the rtable entries having
  `RangeTblEntry.perminfoindex` > 0

  > List<RTEPermissionInfo>

* jointree (FromExpr): 
  
  * table join tree (FROM and WHERE clauses); 
  * also source relation when it is a `MERGE` command, the `FromExpr.fromlist` 
    will have only 1 element, it could be of type `RangeTblRef` or `JoinExpr`. 
    See `transform_MERGE_to_join(parse)`. `FromExpr.quals` will be qualifications
    on the **TARGET result** (not source relation), if target relation is an
    auto-updatable view.

  Difference between `rtable` and `jointree`: rTable is a flat structure that stores
  all the relations invoked, `jointree` references those table entries stored in
  `rtable` using RT indexes.

  A table can appear multiple times in a query, by splitting it and its reference/usage,
  we can only store it once (in `rtable`) and reference it for multiple times.

* mergeActionList (List<MergeAction>): Only set for `MERGE` command, list of actions for `MERGE`

  ```sql
  postgres=# select * from foo;
  id | description 
  ----+-------------
    1 | one
  (1 row)

  postgres=# select * from bar;
  id | description 
  ----+-------------
    1 | 一
    2 | 二
  (2 rows)

  postgres=*# merge into foo 
  postgres-*# using bar
  postgres-*# on foo.id=bar.id
  postgres-*# when matched then
  postgres-*#   update set description = bar.description
  postgres-*# when not matched then
  postgres-*#   insert (id, description) values (bar.id, bar.description);
  ```

  ```text
  :mergeActionList (
    {MERGEACTION 
    :matchKind 0 
    :commandType 2 
    :override 0 
    :qual <> 
    :targetList (
        {TARGETENTRY 
        :expr 
          {VAR 
          :varno 2 
          :varattno 2 
          :vartype 25 
          :vartypmod -1 
          :varcollid 100 
          :varnullingrels (b)
          :varlevelsup 0 
          :varreturningtype 0 
          :varnosyn 2 
          :varattnosyn 2 
          :location 87
          }
        :resno 2 
        :resname description 
        :ressortgroupref 0 
        :resorigtbl 0 
        :resorigcol 0 
        :resjunk false
        }
    )
    :updateColnos <>
    }
    {MERGEACTION 
    :matchKind 2 
    :commandType 3 
    :override 0 
    :qual <> 
    :targetList (
        {TARGETENTRY 
        :expr 
          {VAR 
          :varno 2 
          :varattno 1 
          :vartype 23 
          :vartypmod -1 
          :varcollid 0 
          :varnullingrels (b)
          :varlevelsup 0 
          :varreturningtype 0 
          :varnosyn 2 
          :varattnosyn 1 
          :location 160
          }
        :resno 1 
        :resname id 
        :ressortgroupref 0 
        :resorigtbl 0 
        :resorigcol 0 
        :resjunk false
        }
        {TARGETENTRY 
        :expr 
          {VAR 
          :varno 2 
          :varattno 2 
          :vartype 25 
          :vartypmod -1 
          :varcollid 100 
          :varnullingrels (b)
          :varlevelsup 0 
          :varreturningtype 0 
          :varnosyn 2 
          :varattnosyn 2 
          :location 168
          }
        :resno 2 
        :resname description 
        :ressortgroupref 0 
        :resorigtbl 0 
        :resorigcol 0 
        :resjunk false
        }
    )
    :updateColnos <>
    }
  )
  ```

 


* mergeTargetRelation (int): Range table index to the merge target relation.

  Only set for MERGE query.
  
  > Where is source relation stored? It is stored in `jointree`
  
  If target relation is a regular table, then `mergeTargetRelation` has the
  same value as `resultRelation`. If target relation is a trigger-updatable
  view, then it will be the expanded view subquery that we need to pull data
  from.

* mergeJoinCondition: Only set for `Merge` command, NULL otherwise.  

  > type: Expr or subtype, like BooleanExpr

* targetList: (List<TargetEntry>)

  > `targetList` is also called `tlist` in the pg source tree.

  * For `SELECT`: a list of expr that define the query result
  
    `*` is a special abbreviation that will be expaned by the analyzer
  
    ```c
    /*
     * transformTargetList()
     * Turns a list of ResTarget's into a list of TargetEntry's.
     *
     * This code acts mostly the same for SELECT, UPDATE, or RETURNING lists;
     * the main thing is to transform the given expressions (the "val" fields).
     * The exprKind parameter distinguishes these cases when necessary.
     */
    List *
    transformTargetList(ParseState *pstate, List *targetlist,
					ParseExprKind exprKind)
    ```
    
  * For `INSERT`: the row that will be inserted into the table. During parser and 
    analyzer stage, `targetList` only contains the columns that actually exist in
    the SQL query. Rewriter and planer will normalize the `targetList` by:
    
    1. Add the `TargetEntry`s with default value for missing columns
    2. Reorder `TargetEntry` entries so that they correspond to the column order
    
    ```c
    rewriteTargetListIU() /* src/backend/rewrite/rewriteHandler.c */
    preprocess_targetlist(root) /* src/backend/optimizer/plan/planner.c */ 
    ```
  
    ```SQL
    create table students (id int, name text, major text)
    insert into students (name) values ('foo');
    
    -- NOTE: Before rewriter and planner
    
    :targetList (
      {TARGETENTRY 
        :expr 
          {CONST 
            :consttype 25 
            :consttypmod -1 
            :constcollid 100 
            :constlen -1 
            :constbyval false 
            :constisnull false 
            :location 36 
            :constvalue 9 [ 36 0 0 0 98 105 110 103 111 ]
          }
          :resno 2 
          :resname name 
          :ressortgroupref 0 
          :resorigtbl 0 
          :resorigcol 0 
          :resjunk false
      }
    )
    
    -- NOTE: after rewriter and planner
    DETAIL:  (
       {TARGETENTRY 
       :expr 
          {CONST 
          :consttype 23 
          :consttypmod -1 
          :constcollid 0 
          :constlen 4 
          :constbyval true 
          :constisnull true 
          :location -1 
          :constvalue <>
          }
       :resno 1 
       :resname id 
       :ressortgroupref 0 
       :resorigtbl 0 
       :resorigcol 0 
       :resjunk false
       }
       {TARGETENTRY 
       :expr 
          {CONST 
          :consttype 25 
          :consttypmod -1 
          :constcollid 100 
          :constlen -1 
          :constbyval false 
          :constisnull false 
          :location 36 
          :constvalue 5 [ 20 0 0 0 97 ]
          }
       :resno 2 
       :resname name 
       :ressortgroupref 0 
       :resorigtbl 0 
       :resorigcol 0 
       :resjunk false
       }
       {TARGETENTRY 
       :expr 
          {CONST 
          :consttype 25 
          :consttypmod -1 
          :constcollid 100 
          :constlen -1 
          :constbyval false 
          :constisnull true 
          :location -1 
          :constvalue <>
          }
       :resno 3 
       :resname major 
       :ressortgroupref 0 
       :resorigtbl 0 
       :resorigcol 0 
       :resjunk false
       }
    )    
    ```

    
  * For `UPDATE`: In analyzer, it represents the columns that will be updated. 
    Rewriter merges entries with the same `resno`, the below query will have
    2 `TargetEntry`ies with the same resno 1 as column `arr` gets modified
    twice.
    
    ```sql
    create table with_array (arr text[]);
    update with_array set arr[1]='a', arr[2]='b';
    ```
    
    Rewriter will merge the entires with the same `resno`. The planner extracts
    the `targetList` `resno` numbers into a separate "PlannerInfo.update_colnos"
    (`preprocess_targetlist()`)
    
  * For `DELETE`: looks like this field is empty for `DELETE` statements from
    my observations

* override: If this query contains a `OVERRIDING` clause. If so, what is its kind:

  > [Postgres INSERT doc](https://www.postgresql.org/docs/current/sql-insert.html)
  > 
  > [How to insert value to identity column in PostgreSQL 11.1](https://stackoverflow.com/q/55701029/14092446)

  * OVERRIDING_USER_VALUE: If this clause is specified, then any values supplied
    for identity columns will override the default sequence-generated values.
  * OVERRIDING_SYSTEM_VALUE: If this clause is specified, then any values supplied
    for identity columns are ignored and the default sequence-generated values are
    applied.

  ```sql
  INSERT INTO my_table (id, name) 
  OVERRIDING SYSTEM VALUE 
  VALUES (1, 'Alice');
  ```

* onConflict: If the SQL is an `INSERT` and contains an `ON CONFLICT DO` clause, this 
  field stores that clause.

  > Postgres does not support `UPSERT` before 15, `ON CONFLICT DO` is an alternative 
  > to that

* returningOldAlias (char *): NULL for `INSERT` as it does not have old value
* returningNewAlias (char *): NULL for `DELETE` as it does not have new value
* returningList (List<TargetEntry>)

  The above 3 fields will only be set for `INSERT/UPDATE/DELETE/MERGE` statements
  that can modify data and have `RETURNING` clauses. `returningOldAlias` is the alias
  for the old data (before modification), `returningNewAlias` is for new data (after 
  modification)
  
  ```SQL
  create table foo (id int); 
  delete from foo where id = 1 returning id;
  ```
  
  When you specify a column in the `RETURNING` clause, `INSERT/UPDATE` by default
  give you the new value, `DELETE` gives you the old value. `MERGE` gives you the
  content of the source row plus the content of the inserted, updated, or deleted
  target row.
  
  Users can specify `returningOldAlias` and `returningNewAlias` via:
  
  ```SQL
  RETURNING WITH (OLD AS <old-alias>, NEW AS <new-alias>) <returningList>
  ```

* groupClause: `GROUP BY` clause

* groupDistinct: QUES: I am not sure about this
* groupingSets: QUES: I am not sure about this


* havingQual (List<Node>, too generic?): `HAVING` clause

* windowClause

* distinctClause: DISTINCT or DISTINCT ON clause

* sortClause (List<SortGroupClause>): This list is 1-based

  Representation of `ORDER BY, GROUP BY, PARTITION BY, DISTINCT, DISTINCT ON` items

  ORDER BY/GROUP BY

* limitOffset: OFFSET X

* limitCount: LIMIT x

* limitOption

* rowMarks (List<RowMarkClause>): Parser output representation of `FOR [KEY] UPDATE/SHARE`
  clauses

* setOperations (SetOperationStmt): set-operation tree if this is top level of
  a UNION/INTERSECT/EXCEPT query 
  
  ```sql
  select * from foo 
  union all 
  select * from foo;
  ```
  
  The above query will have 2 RTE_SUBQUERY rtes and its `setOperations` will be
  
  ```c
  struct SetOperationStmt {
    op: Union
    all: trie
    larg: RangeTblRef(1),
    rarg: RangeTblRef(2),
  }
  ```

* constraintDeps: 

* withCheckOptions (List<WithCheckOption>): This field will be initialized by 
  the rewriter. It can be 2 things:

  1. `WITH CHECK OPTION` checks that will be applied to new tuples when inserting
     or updating an auto-updatable view
     
     ```c
     typedef enum WCOKind
     {
         WCO_VIEW_CHECK,				/* WCO on an auto-updatable view */

         // ...
     } WCOKind;
     ```

     ```sql
     create table numbers (num int, is_positive bool);
     create view positive_numbers as (select * from numbers where is_positive) WITH CHECK OPTION;

     -- Since this field will be populated by the rewriter, you have to use this option
     set debug_print_rewritten = true;
     insert into positive_numbers values (-1, false);
     ERROR:  new row violates check option for view "positive_numbers"
     :withCheckOptions (
       {WITHCHECKOPTION 
          :kind 0 
          :relname positive_numbers 
          :polname <> 
          :qual 
              {VAR 
              :varno 2 
              :varattno 2 
              :vartype 16 
              :vartypmod -1 
              :varcollid 0 
              :varnullingrels (b)
              :varlevelsup 0 
              :varreturningtype 0 
              :varnosyn 2 
              :varattnosyn 2 
              :location -1
              }
          :cascaded true
       }
     )
     ```
 
     It rejects writes that do not satisfy the qualification. For a view without 
     this `WITH CHECK OPTION`, these writes will be accepted, but you won't see
     these tuples in `select * from positive_number_without_with_check_option`
     since they do not satisfy the option.
      

  2. `RLS WITH CHECK` policies to be applied when inserting/updating a relation 
     with RLS (row-level security).

     ```c
     typedef enum WCOKind
     {
        // ...

        WCO_RLS_INSERT_CHECK,		/* RLS INSERT WITH CHECK policy */
        WCO_RLS_UPDATE_CHECK,		/* RLS UPDATE WITH CHECK policy */
        WCO_RLS_CONFLICT_CHECK,		/* RLS ON CONFLICT DO UPDATE USING policy */
        WCO_RLS_MERGE_UPDATE_CHECK, /* RLS MERGE UPDATE USING policy */
        WCO_RLS_MERGE_DELETE_CHECK, /* RLS MERGE DELETE USING policy */
     } WCOKind;
     ```

* stmt_location: start offset of the statement in the SQL string
* stmt_len: len of this statement