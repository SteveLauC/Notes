Every function has a volatility classification, which is a promise of the function
behaviors that optimizer rely on to optimize the function calls.

Postgres has 3 volatilities:

* VOLATILE

  A VOLATILE function can do anything, including modifying the database. It can
  return different results on successive calls with the same arguments. The 
  optimizer makes no assumptions about the behavior of such functions. A query
  using a volatile function will re-evaluate the function at every row where 
  its value is needed.
  
  A function is VOLATILE if:
  
  1. It is Non-Deterministic: It can return different results even when given
     the exact same arguments (e.g., random(), timeofday()).
  2. It has Side Effects: It modifies the database (e.g., performs an UPDATE 
     or DELETE, or calls setval() on a sequence).
  
* STABLE

  A STABLE function cannot modify the database and is guaranteed to return the same
  results given the same arguments for all rows **within a single statement**. 
  
  This category allows the optimizer to optimize multiple calls of the function 
  to a single call. In particular, it is safe to use an expression containing such 
  a function in an index scan condition. (Since an index scan will evaluate the 
  comparison value only once, not once at each row, it is not valid to use a 
  VOLATILE function in an index scan condition.)

* IMMUTABLE

  An IMMUTABLE function cannot modify the database and is guaranteed to return the same
  results given the same arguments **forever**. 
  
  This category allows the optimizer to pre-evaluate the function when a query calls it
  with constant arguments. For example, a query like `SELECT ... WHERE x = 2 + 2` can be 
  simplified on sight to `SELECT ... WHERE x = 4`, because the function underlying the 
  integer addition operator is marked IMMUTABLE.
  
For functions written in SQL or in any of the standard procedural languages, there is a 
second important property determined by the volatility category, namely the "visibility 
of any data changes that have been made by the SQL command that is calling the function". 
A VOLATILE function will see such changes, a STABLE or IMMUTABLE function will not. 
This behavior is implemented using the snapshotting behavior of MVCC (see Chapter 13): 
STABLE and IMMUTABLE functions use a snapshot established as of the start of the calling 
query, whereas VOLATILE functions obtain a fresh snapshot at the start of each query they execute.

> Functions written in C can manage snapshots however they want, but it's usually
> a good idea to make C functions work this way too.

Because of this snapshotting behavior, a function containing only SELECT commands
can safely be marked STABLE, even if it selects from tables that might be undergoing 
modifications by concurrent queries. PostgreSQL will execute all commands of a STABLE
function using the snapshot established for the calling query, and so it will see a 
fixed view of the database throughout that query.