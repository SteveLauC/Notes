1. 生命周期标记的例子

    ```rust
    fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str 
    {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    ```

    我们给`x`和`y`分别标记生命周期`'a`和`'b`，并且给返回值标记了`'a`的生命周期，
    所以当返回值是根据`x`得来的，那自然是没有问题的，返回值一定不是悬垂指针。但假
    返回值是由`y`得来的，就不一定了，所以我们为了确保返回值一直合法，需要指定了
    `'b: 'a`这样当返回值是由`y`得来的话，y活的时间更长，返回值也一直是合法的了。

    ```rust
    fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str 
    where 'b: 'a
    {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    ```

    ```rust
    fn main() {
        let str1 = String::new();
        {
            let str2 = String::new();
            longest(&str1, &str2);
        }
    }
    ```

    看上面的调用的例子，发现，我们传入的`y`的实参的生命周期明显长于`x`的实参的生命周
    期，这是否和函数中`'b: 'a`冲突呢？其实不冲突的，要注意生命周期是为了压制悬垂指针
    ，在返回指针的函数中，想要返回的不是悬垂指针，那么这个指针就得来自函数参数(而不是
    指向局部变量)，并且对参数和返回值的生命周期关系进行限制。所以`'b: 'a`其实指的是返
    回值的生命周期`'a`和参数`y`的生命周期`'b`之间的关系，而不是参数`x`的生命周期`'a`
    和`y`的生命周期`'b`的关系。
