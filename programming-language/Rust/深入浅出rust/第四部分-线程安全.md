1. 创建一个线程可以使用`thread::spawn()`来创建，注意这个函数直接返回`std::thre
   ad::JoinHandle`这个handler。如果想更定制地创建线程，可以使用`std::thread::
   Builder::new()`这个函数来创建,可以配置name和stack_size。并且这个函数的返回值
   还是一个result，`std::io::Result<JoinHandle, std::io::Error>`，而`thread::spawn`
   的返回值直接就是`JoinHandle`，所以说如果你要创建的线程可能会失败，那么使用builder
   来创建比较好。

2. rust中的线程在其中用`std::thread::Thread`这个结构体来表示，想要拿到获得这个结
   构体有2种办法:
   1. use std::thread::current; 使用这个函数返回调用此函数的thread的本体
   	  ```rust
      pub fn current() -> Thread
      ```
   2. 在`std::thread::JoinHandle`的基础上调用`thread`函数，这个函数是`impl JoinHandle`
      里的，注意其返回的是不可变引用。
      > The thread::current function is available even for threads not spawned by the APIs of this module.
      ```rust
      pub fn thread(&self) -> &Thread
      ```
3. 这个`thread`结构体有3个自己的方法
   1. `pub fn id(&self) -> ThreadId`: 返回这个线程的id，id的数据结构是一个专用的结
      构体，但其内部仅仅是一个`pub struct ThreadId(NonZeroU64);`，可能做了更多的抽
	  象吧。
   2. `pub fn name(&self) -> Option<&str>`，返回线程的名字。
   3. `pub fn unpark(&self)`这个我还看不懂。

4. Duration的2种最常见的创建的方法:
   1. `pub const fn new(secs: u64, nanos: u32) -> Duration`
   2. `pub const fn from_secs(secs: u64) -> Duration`

5. `std::thread`这个module的函数
    * thread::spawn()用来创建一个线程
	* thread::current()返回当前线程
	* thread::park() 将当前线程block掉  这个park会block掉，想要unnlock就使用`std::thread::Thread::unpark()`
	* thread::sleep(Duration)让当前线程睡眠至少Duration的时间
	* thread::yield_now()让当前线程放弃一个时间片

6. 我惊了，thread居然有自己专用的Result
   ```rust
   use std::thread::Result;
   type Result<T> = Result<T, Box<dyn Any + Send + 'static>>;
   ```

