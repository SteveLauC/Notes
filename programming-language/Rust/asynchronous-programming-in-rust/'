#### 1.1
1. diff between `async` and `muplithreading`

   举个例子，后厨需要做一个鸡蛋，烤一份土豆 
   * sync: 做鸡蛋，烤土豆(顺序执行)
   * async, single threaded: 做鸡蛋，设置一个定时器，然后烤土豆，再设置一个定时器
   * async, multithreaded: 一个厨师做鸡蛋，另一个厨师烤土豆

   > async is about tasks while mutlithreading is about workers


   > [link](https://stackoverflow.com/q/34680985/14092446)

   有好几种concurrent models，os threads 和 async programming是其中的两种

2. OS threads比较适合数量较小的工作，因为它会用CPU和memory，线程切换是很费资源的。
   而async则支持多得多的任务数量，而且有少得多的cpu和memory的负载。在rust中，使用
   async会导致编译binary的大小增大，因为bundle了runtime

#### 1.3
1. async函数返回的是一个`Future<ReturnTypeOfThatFn>`，每一个`Future`都需要在`executor`
   上进行执行

   ```rust
   // 使用`futures`crate中的`block_on`这个`executor`
   // `block_on` will block the current thread until the Future is complete
   use futures::executor::block_on;

   async hello() {
       println!("hello");
   }

   fn main() {
       let f = hello();
       block_on(f);
   }
   ```

   ```shell
   $ cargo run
   hello
   ```
