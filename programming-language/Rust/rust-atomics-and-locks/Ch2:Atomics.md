> In the second chapter we’ll learn about Rust’s atomic types and all their 
> operations. We start with simple load and store operations, and build our way
> up to more advanced compare-and-exchange loops, exploring each new concept 
> with several real-world use cases as usable examples.
>
> While memory ordering is relevant for every atomic operation, that topic is 
> left for the next chapter. This chapter only covers situations where relaxed 
> memory ordering suffices, which is the case more often than one might expect.

