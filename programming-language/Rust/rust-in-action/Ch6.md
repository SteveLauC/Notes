##### 6.3.2
1. rust有一个 `std::ops::Drop` trait，其中有一个方法
   ```rust
   pub trait Drop {
  	   fn drop(&mut self);
   }
   ```
   这个类似cpp中的析构函数，可以用来定制一些变量被析构时的行为。
   但一个变量的owner的lifetime到期时，其会被自动地调用。**rust并不允许我们手动地在代码中调用 `Drop::drop()` 这个这个函数**

   如果我们想要提前地结束一个变量的生命周期，可以调用`pub fn drop<T>(_x: T) {}`来将所有权转移到空的没有用的空scope中。


2. 分配在heap上的东西有一个显著地共同特点，那就是他们都需要使用在stack上的指针去间接地访问它。



3. 在使用rustc手动编译文件时，如果要设置代码优化的级别，可以使用参数`--code-gen opt-level=0` 。


##### 6.3.3
1. 什么是dynamic memory allocation?
   dynamic memory allocation指的是程序在运行时申请并且得到内存，这一部分的内存是在编译时期无法确定的。当申请时，我们的程序会向os请求
   但在程序和os之间，还有一个allocator作为中间人进行申请。



##### 6.4.3
1. 程序能接触到的内存只有虚拟内存，它看不到物理内存。

2. MMU内存管理单元负责将虚拟内存和物理内存之间进行映射，page table页表是进行映射用的工具，前者是硬件，后者是软件。

3. 这种在虚拟内存和物理内存之间的翻译是需要成本的，当你在使用虚拟机时，虚拟机里跑的程序经历了两层映射，更加的损耗。

4. x86-64的内核和用户区的大小是等大的

5. pointer reference memory address 这3样东西在os的眼里是没有区别的，仅在高级语言这一层次上有区别，因为这是高级语言的特性。




