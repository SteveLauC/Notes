* 文件的路径 使用宏替换进行 

```c++
#define FILEPATH "文件的路径"
```

* cpp如何判断一个文件是否未空

  ```cpp
  ifstream ifs; //利用的是ifstream的实例化对象进行
  char ch; //需要借助一个字符
  ifs >> fh; //往字符里写东西 
  //关键一步
  ifs.eof() //这个函数返回值为真时，表明文件为空
  ```

* cpp中如何判断一个文件不存在

  ```cpp
  ifstream ifs;
  ifs.open("路径的字符串", ios::in); //去尝试打开文件
  ifs.is_open()//当返回假的时候 也就是文件没有被打开 那么就是文件不存在了
  ```

* 如何在内存和磁盘中进行数据的交互

  内存像是数据的中转站，而磁盘是数据的最终目的地

  我们操作数据，起初都是在内存中进行操作，在内存中操作好了，然后再将操作好的数据写到磁盘中去 

  在内存中暂存数据，我们是new的一个数组，而往磁盘中写数据，是利用cpp的写文件

* 面向对象的编程思想
  1. 封装：在这个职工管理系统中，我们有一个职工管理类，这个类有属性和一些方法，就专门负责对职工的一些东西进行封装操作
  2. 多态，职工分为employee，manager和boss三种，而这三类都是继承子worker类这个基类，worker基类里有相应的属性，还有一些纯虚函数的方法。留意，属性是要放在基类里面的，然后方法基类里是纯虚的函数，目的是为了在子类中进行重写。然后基类的属性会被子类继承，子类要有自己的构造和析构函数，在构造函数中要对这些继承来的属性进行初始化，析构中进行适当的回收。父类是一个抽象类，不能创建实例，自然就没有构造函数和析构函数了
     1. 利用多态，父类指针或引用可以接受子类的指针或子类，这就是我们在内存中的存储策略，每次new一个employee(或其它)，都是一个employee(或其他)的指针，然后用父类的指针去接受它，也就是worker * = employee *，创建的问题解决了，接下来是内存中的存储。
     2. 创建之后，是一个worker *，自然就是用worker *的数组去存放数据。对这个数组的管理，是要用一个二级指针worker **去管理这个数组。

* cpp如何清空文件

  ```
  //方法1
  ofstream ofs;
  ofs.open(路径, ios::out); //或者是ofs.open(路径，ios::trunc);
  ofs.close;
  ```

  投机取巧的方法，因为ofs.open会对文件进行清空，为后续的数据写入做准备，但我们并没有对文件进行写入，所以就是清空文件了

  ios::trunc单独使用和ios::out同义

