1. 无符号数算术移位，算术左移可能会发生溢出，通常判断溢出去的位是不是1来检测。
   如果是1的话，说明溢出了。

2. 对于有符号数，逻辑左移溢出的检测，看被溢出的位和新的符号位是不是相同，若相
   同，则发生了溢出。

3. 无符号数算术右移，最后的终点是0

4. 有符号数逻辑右移，需要看其为正或者为负。若为正数，则右移的终点和无符号数右
   移是一样的，均为0；若为负数，右移的终点为全1，即为-1。

   > 需要注意的是，有符号数中的负数，逻辑左移其值在变小，逻辑右移其值在变大。


5. 字节数较小的数据类型扩展到较大的数据类型，发生的是符号扩展还是算术扩展，看
   被扩展的数是有符号还是无符号的。如果是有符号的，则发生的是符号扩展，若是无
   符号数，发生的则是算术扩展。

6. 给出如下代码

    ```rust
    fn main() {
        let i: i32 = 32768;
        let si: i16 = i as i16;
        let j: i32 = si as i32;
        assert_eq!(i, j);
    }
    ```

    判断下`i`和`j`是否相等，答案是不相等。因为si的机器数是
    `10000000 00000000`
    并且是有符号数，符号扩展为32位，变成了
    `11111111 11111111 10000000 00000000`
    再按照有符号32位数解释这4个字节，则是-32768. 

    其原因在于，从`i`截断到`si`时发生了溢出，`32768`是无法在`i16`这个类型
    中表示的，故无法截断

    ```rust
    use std::convert::TryFrom;

    fn main() {
        let i: i32 = 32768;
        let si = i16::try_from(i);

        if si.is_err() {
            println!("Can not be successfully converted");
        }
    }
    ```

    ```shell
    $ cargo run -q
    Can not be successfully converted
    ```