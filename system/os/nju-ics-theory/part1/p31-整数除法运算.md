1. 有符号整数的除法，除了`-2^(n-1)/-1`会溢出外，其余情况都不会溢出。因为其他的情况
   被除数的绝对值一定大于商的绝对值，所以一定是可以表示的。除数不会是0，所以绝对值
   只能是1/2/3之类的，所以商的绝对值相对于被除数的绝对值一定是变小了。

2. 因为整数除整数的商还是整数，所以在不能整除的时候，最后取的整数商是在小数的基础上
   往0靠近的，也可以理解为直接将小数部分截去。

3. 取负指令的电路实现就是用模-被操作数，也就是求一个数的相反数的补码表示。

4. 假如说
   
   ```c
   int x = -2147483648;
   int y = x/-1;
   ```
   中的`/-1`被优化为`neg`指令，对其机器数直接操作，则y的机器数为`1000(31个0)`，则理应
   溢出的操作就没有被检测到了。

   但假如按照除法做，`2147483648`在`i32`中是无法表示的。


5. 除数是2的幂的话，可以使用右移来实现，无符号数左边补0，有符号数补符号位:  
   
   1. 可以整除，右边移出去的都是0，直接右移
   2. 不可以整数，右边会溢出1，需要单独处理:  
      1. 无符号数或有符号正数，移出去的位直接丢掉，向0靠齐，截掉小数部分。
      2. 有符号数负数，将被除数先纠偏，加上`2^k - 1`(k是右移的位数)，再右移k位，然后丢掉移
      出去的位。

      ![illustration](https://github.com/SteveLauC/pic/blob/main/Screen%20Shot%202022-03-26%20at%2011.54.30%20AM.png)
      ![patch](https://github.com/SteveLauC/pic/blob/main/Screen%20Shot%202022-03-26%20at%2011.56.33%20AM.png)

    

6. 实现一个函数，其功能是计算其int参数除32，只能使用右移/加法/位运算

   > 使用位运算判断被除数能否被32整数，若能，则直接右移5位返回；若不能，则纠偏，
   再右移5位返回。

   视频中给的答案对情况的分类只分了正数负数的情况，因为负数可以整除和不可以整除
   不加偏移和加偏移，算完的结果是一样的。(为什么呢)

   ![answer](https://github.com/SteveLauC/pic/blob/main/Screen%20Shot%202022-03-26%20at%2012.29.04%20PM.png)


   ```rust
   // 这个实现严格按照算法来的，但用了比较操作
   fn div32(x: i32) -> i32 {
       // check if x is divisible by 32
       let remainder: i32 = if x >= 0 {
           x & 0b11111
       } else {
           assert!(x != i32::MIN);
           -x & 0b11111           // may overflow
       };

       if remainder == 0 {
               x >> 5
       } else {
           if x >= 0 {
               x >> 5
           } else {
               (x + 2_i32.pow(5) -1) >> 5
           }
       }
   }
   ```
