1. 计算机中所有的运算都是基于加法实现的，也就是靠我们的n位整数加减运算部件
   来完成的。

2. 加法器并不知道自己所运算的是有符号数的运算，还是无符号数的运算。它只是将
   来的2个二进制数以及进位位进行相加

3. 加法器并不判断运算结果的对错，它总是取最低n位作为结果，并生成一些标志信
   息。

4. 在整数加法部件运算中会生成一些标志信息，如零标志ZF，溢出标志OF，进借位标
    志CF，符号标志SF。这些标志被称为条件标志，是在运算电路中产生的，会被记
    录到专门的寄存器中，存放这些条件标志的寄存器成为程序状态寄存器或者标志寄
    存器，每个标志对应标志寄存器中的一个标志位。比如X86中的`EFLAGS`寄存器。 

5. 为什么要有这样子的条件标志？  
   是为了在分支指令(条件转移指令)中被用作是否转移的条件

6. OF溢出标记   
   ![alu](https://github.com/SteveLauC/pic/blob/main/Screenshot%20from%202022-03-14%2012-49-23.png)

   当`A`和`B'`同符号(同为正或者同为负)，所得到的结果`sum`的符号与`A/B'`的
   符号不同，则发生了溢出。OF设置为1，否则没有溢出，OF设置为0.

   一个正数和一个负数(占用相同的字节数)相加，是绝对不会溢出的，以`i8`
   为例子：  

   * 负数的范围: [-127, -1]
   * 正数的范围: [1, 126]
   * i8的范围: [-127, 126]

   可以发现无论如何，都不会溢出。

7. ZF零标记  
   这个比较简单，只有当sum为0时，ZF为1，否则为0.

8. CF进/借位标记  
   CF = Cout XOR Sub