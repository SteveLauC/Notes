1. 计算机中所有的运算都是基于加法实现的，也就是靠我们的n位整数加减运算部件
   来完成的。

2. 加法器并不知道自己所运算的是有符号数的运算，还是无符号数的运算。它只是将
   来的2个二进制数以及进位位进行相加

3. 加法器并不判断运算结果的对错，它总是取最低n位作为结果，并生成一些标志信
   息。*错误的判定是靠软件后来实现的，硬件不管对错，只知道0和1*

4. 在整数加法部件运算中会生成一些标志信息，如零标志ZF，溢出标志OF，进借位标
    志CF，符号标志SF。这些标志被称为条件标志，是在运算电路中产生的，会被记
    录到专门的寄存器中，存放这些条件标志的寄存器成为程序状态寄存器或者标志寄
    存器，每个标志对应标志寄存器中的一个标志位。比如X86中的`EFLAGS`寄存器。 

5. 为什么要有这样子的条件标志？  
   是为了在分支指令(条件转移指令)中被用作是否转移的条件

6. OF带符号数溢出标记   
   ![alu](https://github.com/SteveLauC/pic/blob/main/Screenshot%20from%202022-03-14%2012-49-23.png)

   判定方法:  
   1. 当`A`和`B'`同符号(同为正或者同为负)，所得到的结果`sum`的符号与`A/B'`的
   符号不同，则发生了溢出。OF设置为1，否则没有溢出，OF设置为0.
   2. OF=最高位的进位XOR次高位的进位
   > 第1种判断方法比较符合人类的直觉，但对于计算机则是比较难的，第二种直
   接将Cn-1和Cn通到异或门交给OF
    
   ![pic](https://github.com/SteveLauC/pic/blob/main/Screenshot%20from%202022-03-16%2009-14-38.png)


   一个正数和一个负数(占用相同的字节数)相加，是绝对不会溢出的，以`i8`
   为例子：  

   * 负数的范围: [-127, -1]
   * 正数的范围: [1, 126]
   * i8的范围: [-127, 126]

   可以发现无论如何，都不会溢出。

7. ZF零标记  
   这个比较简单，只有当sum为0时，ZF为1，否则为0。也就是所有的位都通到
   或非门，或非门的输出交给ZF。

8. CF进/借位标记(Carry flag/C flag) 
   
   > 如果做的是加法运算，CF表示进位；如果做的是减法运算，CF表示借位

   `CF = Cout XOR Sub`  
   当做加法操作的时候，就直接看进位位Cout就好了。当进行减法操作的时候，Sub=1，
   则`CF=~Count`，一个数减去另一个数不可能发生进位，如果发生了进位，则一定是
   有了借位吗？

9. SF符号标记  
   只需要将sum的第一位给它就好 

10. 加法溢出的判断:  

    1. 无符号数加法看其CF/Count是否为1，若产生进位CF/Count=1，则溢出。
    所以N位加法器可以用来加两个无符号数，但不能加有符号数，因为它没有OF标
    记，不能判断溢出。
    2. 有符号数看OF标志
    
    举例:  
    n=8, 107+46 判断是否溢出  
    ![pic](https://github.com/SteveLauC/pic/blob/main/Screenshot%20from%202022-03-15%2011-41-09.png)

    发现进位位为0，符号位(如果有的话)为1。如果两个数都是无符号数，因为进位为0，则没有溢出。
    如果两个数是有符号数，则两个数为正数，结果为负数，发生了溢出。

11. 计算机如何比较俩个数的大小，进行减法操作:  
    * 如果两个数是无符号数，则若CF=0，被减数大于减数。
    * 如果两个数是有符号数，若OF=SF，被减数大于减数。