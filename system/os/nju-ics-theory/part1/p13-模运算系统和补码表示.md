1. 补码是一种模运算，它的减法可以用加法来实现。以时钟为例，从10点播到6点有两种播
   法，可以加，也可以减
   
   1. 10 - 4 = 6
   2. 10 + 8 = 6
 
   回想在数字逻辑中我们学的补码的减法运算公式，`[N1-N2]补 = [N1]补 + [-N2]补`，
   `10-4 = 10 + 8`
   
   > 为什么在模12中，4的负数是8，因为4+8=12 (一个数和它的相反数相加为0)。就像4个
   bit，补码表示，其模是`10000`，为16，`4(0100)`，`-4(1100)`，`0100+1100 = (1)0
   000`，进位位被舍去
   
   > 一个数和它的相反数相加为0，从这里也可以看出原码两个0的不好的地方。

   > 4个bit，-4的补码是16-4=12(1100)，忽略符号位的权。然后引出的就是我们课堂上教
   的计算负数补码的公式的，比如-4的补码，是4的补码各位取反再+1。但是计算机不是这
   样做的，它直接用模减去4的补码。课堂上教的是对人比较友好的计算方式。
  
   > 只要表示的位数是有限的并且符号位不单独编码(不像原码)，而是编码在权重里，好像
   都是一个模系统，比如有限的bit数的反码和补码表示，时钟有限的12个数字。
   

2. 补码的定义
   [x]补 = (2^n + x)mod(2^n)
   
   * 当x为正数的时候，(2^n + x) mod (2^n) = x
   * 当x为负数的时候，(2^n + x) mode (2^n) = 2^n + x (因为x为负数，所以一定小于2^n，
   mod运算无用) = 2^n - |x| .(也就是直接用模-正数)
