1. 有符号整数的乘法如何判断结果是正确的，比如
   
   ```c
   #include <stdlib.h>
   int multiply(int x, int y) {
       int z = x*y;
       if (x==0||z/x==y) {
           return z;
       }

       exit(1);
   }
   ```

   在高级语言层面可以使用`x==0||z/x==y`这个逻辑表达式来进行判断。


   但在硬件层面，由于乘法的电路运算是把乘数的每一位与被乘数进行乘法运算并求和，所
   以n位数与n位数的乘法，需要`2n`的位数来存放结果。

   ![illustration](https://github.com/SteveLauC/pic/blob/main/IMG_1622.jpg)

   而我们又知道，n位有符号数的合法范围在`[-2^(n-1), 2^(n-1)-1)`中，所以如果n位结
   果合法，则高n位的值一定是低n位的MSB，也就是说结果的高n+1位一定全0或者全1.

2. 无符号整数的乘法如何判断溢出，高级语言层面也使用有符号整数的那个逻辑表达式。

   从电路层面上检测可以使用高n位全为0来判断。(注意是高n位而不是n+1位，毕竟是无符
   号数)

3. 无符号数和有符号数的运算，假如被乘数和乘数的机器数是一样的，则运算结果的2n-1位
   应该是一样的，高位应该是符号扩展或者是0扩展，导致2n位的结果不一样。

   所以我们取运算结果的低n位作为运算结果，则无符号数和有符号数的n位结果是一样的。

   所以我们可以使用无符号数的乘法电路来计算有符号数的乘法，只不过我们抛弃了高n位，
   从电路层面检测溢出的功能去掉了。

   ![ppt](https://github.com/SteveLauC/pic/blob/main/Screen%20Shot%202022-03-25%20at%2010.29.12%20AM.png)
