1. 在c中如何将`fd`和`FILE *`进行转化
   
   ```c
   # include <stdio.h>
   FILE *fdopen(int fd, const char *mode);  // fd to FILE
   int fileno(FILE *stream);                // FILE to fd
   ```
   
   > 其实是POSIX API，而不是glibc
   

   在rust中可以

   ```rust
   use std::os::unix::io::{FromRawFd, AsRawFd, RawFd};
   use std::fs::File;

   let f: File = File::from_raw_fd(fd);
   let fd: RawFd = f.as_raw_fd();
   ```
   
2. UNIX的4种数据源

   1. 磁盘文件
   2. 设备
   > 使用`open`来连接，使用`read/write`读写
   3. 管道
   > 使用`pipe`来连接，使用`read/write`读写
   4. socket
   > 使用`socket/listen/connect`来连接，使用`read/write`来读写
   
   > 一切皆是文件，都可以用`file descriptor`来表示，然后使用`read/write`来读写
   
3. bc与dc
   bc是前端，dc是后端，两种通过pipe进行通信

4. `FILE *popen(const char *command, const char *type)`系统调用
   
   和`fopen(const char * pathname, const char * mode)`比较像，但不是打开文件，
   而是打开一个进程。

   `fopen`的实现流程:
   1. 父进程: 创建一个`pipe`
   2. 父进程: `fork`得到一个子进程
   3. 父进程: 依`type`是`r`还是`w`，对`pipe`拿到的`fd[2]`，由`fd`转为`FILE *`
   如果是`r`，则将读的一端`fd[0]`转为`FILE *`，`w`则将`fd[1]`转为`FILE *`
   4. 父进程: `close()`掉没有转为`FILE*`的`fd`
   5. 子进程: 对输入输出进行重定向，如果`type`是`r`，则将stdout重定向到`fd[1]`；
   如果是`w`，则将stdin重定向到`fd[0]`
   6. 子进程: close(fd[0]);close(fd[1])
   7. 子进程: 调用`exec`系函数，执行`bash -c command`

   > 由于我们在实现中只会创建一个`pipe`，而`pipe`是`unidirectional`的，所以`type`
   这个参数只能是`w`或`r`
