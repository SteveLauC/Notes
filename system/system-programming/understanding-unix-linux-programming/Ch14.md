1. 在UNIX里面线程是用`pthread_t`来标识的，类似于进程的`pid`

   > Rust里面有`std::os::unix::thread::RawPthread`

2. POSIX的线程api，使用`pthread_create`来创建一个线程，使用`pthread_join`来终结
   一个线程
    ```c
    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
    int pthread_join(pthread_t thread, void **retval);
    ```

    在`pthread_create`中的参数，`thread`放预先定义好的`pthread_t`的指针，`attr`
    放置线程的属性，`start_routine`是函数指针，其返回值是`void*`，参数也是`void *`
    最后一个参数是传给`start_routine`的

    `pthread_join`的`thread`就是`pthread_t`的值，`retval`是用来查看线程的返回值
    的

3. 在c里面如何使用mutex来对共享变量进行锁定

    ```c
    #include <pthread.h>
    
    int n = 0; // global variable
    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // mutually exclusive flag

    void * change_n(void *);

    int main(void) {
        int n = 0;

        pthread_t t1;
        pthread_t t2;

        pthread_create(&t1, NULL, )
    }

    void * change_n(void * p) {
        pthread_mutex_lock(&lock);
        n += 1; 
        pthread_mutex_unlock(&lock);
    }
    ```

    当一个进程在调用`pthread_mutex_lock`的时候，如果别的进程已经将这个互斥信号量
    锁住了，那么当前的进程就只能等待，只有当占用信号量的进程解锁，当前进程才可以
    访问`n`

    `pthread_mutex_lock`是等待互斥锁解开然后再锁住，而`pthread_mutex_unlock`则是
    对互斥锁进行解锁

4. 受限于POSIX创建线程api的定义，`start_routine`就只能是这个样子
   `void * start_routine(void *)`，但其实这个灵活度还蛮高的，因为它是`void *`，所
   以你可以定义自己的结构体，然后传进去

5. rust的线程api是不允许你借用一个栈上的数据的，因为rust的线程创建允许当前被创建的
   线程outlive当前线程，刚被创建的线程执行的时候当前线程可能就已经没有了，此时再去
   访问这个栈数据就是非法内存访问了。正因为，其api要求你`move`掉那些东西。

   但有时我们心理清楚创建的线程不会outlive主线程，这时可以用`corssbeam`的`scope`函数
   来创建线程

   > scope, for spawning threads that borrow local variables from the stack.
