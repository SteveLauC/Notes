1. unconnected的UDP编程
   
   * server: 
       1. `socket`拿到一个socket
       2. 将拿到的socket和自己的地址进行`bind`
       3. 直接调用`recvfrom`从`server_socket`中进行读写，这里一定要调用`recvfrom`
       并且要留住client的地址，这样才可以待会再写回去

       > 和TCP相比，省略了`listen/accept`，而且读写是从`server_fd`而不是`client_fd`
       中进行的

   * client:
        1. `socket`拿到一个socket
        2. 准备一个server的地址
        3. 直接调用`sendto`进行读写

        > 和TCP相比，省略了`connect`

    > 其实在client这一侧，我们也可以像server那样做，`socket/bind/recvfrom|sendto`，
    只不过`bind`的地址改为`0.0.0.0:0`不就可以了吗?但其实对client进行bind不是那么好
    的习惯，应该不显示调用bind而由系统进行分配


2. rust的UDP，在创建socket时必须要制定具体的IP/PORT，这和C中我们做的不一样，可以
   使用

   ```rust
   use std::net::UdpSocket;

   fn main() {
       let client: UdpSocket = UdpSocket::bind("0.0.0.0:0").unwrap();
   }
   ```

   这样就可以由OS去选择具体的IP/PORT

3. rust的slice有一个`file`方法，可以像c的`memset`一样工作

   ```rust
   pub fn fill(&mut self, value: T)
   where
       T: Clone, 
   Fills self with elements by cloning value
    ```

4. `recv`和`read`的区别是？`send`和`write`的区别是？
    
   手册上说其主要区别在于`recv`和`send`多了一个`flag`位，但还有一个区别就是`recv`
   和`send`只能用于`socket`的`fd`，而`read/write`则是更加通用的，可以用于任何的fd

   SO上还有人说在对于UDP编程时，数据包的长度为0时，使用`read/recv`其行为会有不同，
   俺不是很懂

   [link](https://stackoverflow.com/questions/1790750/what-is-the-difference-between-read-and-recv-and-between-send-and-write#:~:text=The%20difference%20is%20that%20recv,band%20messages...).)

5. UDP也可以是`connected`或者`unconnected`，如果在拿到`socket`后像TCP那样，调用
   `connect`函数，那么这个UDP也就是`connected`的了

   > 在rust的std中也有所体现，`UdpSocket`结构体也有一个`connect`方法。而且这个结
   构体有`send/send_to``recv/recv_from`的方法，适用于`connected/unconnected`的报
   文

6. 对于写，是使用`send`还是`sendto`函数

   对于`connected`的socket，我们使用`send`函数，而对于`unconnected`的socket，使用
   `sendto`。那么`TCP`使用`send`(or write)，而对于UDP，取决于是否`connected`

