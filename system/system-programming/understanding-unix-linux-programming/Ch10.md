1. 所有UNIX工具都使用文件描述符0/1/2，且假设他们已经被打开，可以进行读/写/写了

2. 重定向操作是由shell而不是由程序完成的

3. 重定向并不会被当作参数传递给程序

   ```rust
   // listargs.rs
   use std::env::args;

   fn main() {
       args().enumerate().for_each(|(idx, arg)| println!("args[{}] {}", idx, arg));
   }
   ```
   比如上面这个程序，使用`./listargs >out 1 2 3`
   
   ```shell
   $ ./listargs >out 1 2 3
   $ cat out
   args[0] ./listargs
   args[1] 1
   args[2] 2
   args[3] 3
   ```
   
   `>out`并没有被当做参数传给`listargs`程序

   而且可以写在命的任何位置，`>out ls`这种写法都是可以的，看起来我的shell的解析要重新做了...
   再者，它是允许`2>`或者`1>`的写法的，那解析的时候要花些功夫了
   
   ```shell
   $ >out ls
   $ cat out
   ...
   ```

4. 文件描述符(file descriptor)和最低可用文件描述符(lowest available file descriptor)的概念

   每一个进程都有一组已经打开的文件，在内部使用数组表示

   ```c
   FILE opened_file[X] = {stdin, stdout, stderr ...};
   ```

   而文件描述符就是某一个文件在这个数组中的索引

   每当进程在要打开一个新文件时，会为其分配当下可以分配的最小文件描述符，也就是从前往后遍历`opened_file`，将第一个空位置(未被占用的)分配给它
   

5. 重定向是shell做的，而不是程序做的。在程序中使用print就是输出到stdout，也就是fd1的。所以当我们要重定向到文件中去，要做的就是在shell
   这个层次中将目标文件的fd变为1。
   
   > 所以重定向就是shell做的关于文件描述符的把戏?你想要重定向到某个文件，就是将这个文件的fd变为0/1/2
   
6. 将stdin重定向到文件
   
   1. close-then-open方法，即先关闭fd0，然后再打开目标文件，由于最低可用文件描述符，这个文件的fd就自动变为了0，也就完成了重定向。
   2. open-close-dup-close: 先打开目标文件得到fd_file，然后关闭fd 0，然后使用`dup(fd_file)`为文件增加一个文
      件描述符，由于刚关闭了0，所以dup会拿到0，这样文件就有0和fd_file两个fd了。然后`close(fd_file)`，就只剩下0这个fd了
   3. open-dup2-close: 先打开目标文件，拿到fd，然后使用`dup2(fd, 0)`，将`0`fd抢过来，再`close(fd)`
   
   > 从race condition的角度讲，貌似只有使用`dup2`这个方法是安全的
   
   > stdout/stderr的`>`重定向是一样的，`>>`这样的重定向只需要将文件打开的`Flag`加一个`O_APPEND`

7. 文件描述符和已打开的文件的关系

   一个文件可以对应多个文件描述符，但一个文件描述符只能对应一个文件
   
   > 所以文件描述符还是可以唯一标识一个已打开的文件的
   
   ![pic](https://github.com/SteveLauC/pic/blob/main/Screenshot%20from%202022-05-09%2020-04-38.png)
   
8. `int dup(int oldfd)`系统调用，当你一个已经打开的文件，想再拥有一个文件描述符时，可以使用这个系统调用。比如一个已打开的文件拥有fd 3
   ，想再拥有一个fd，就可以使用`dup(3)`来做到，这样就会按照最低可用文件描述符原则再给此文件分配一个可用的fd，然后这个文件就有2个fd了

    `int dup2(int oldfd, int newfd)`，这个和`dup`很像，它也会给`oldfd`所指向的文件再加上一个新的fd，但是新
    fd的分配不是使用最小可用文件描述符来做的，而是让程序员指定(newfd)的。如果`newfd`事先已经被打开了，则直接将其关闭，抢过来
    
    > The dup2() system call performs the same task as dup(), but instead of 
    using the lowest-numbered unused file descriptor, it uses the file descriptor 
    number specified in newfd.  If the file descriptor newfd was previously open
    , it is silently closed before being reused.
    
    可以看出来`dup2(old_fd, new_fd)`其实就是`close(new_fd) + dup(old_fd)`的结合，但有一点不一样的是，
    `dup2`将这两个操作变为了原子操作，避免了race condition。
    
    > The  steps of closing and reusing the file descriptor newfd are performed 
    atomically.  This is important, because trying to implement equivalent functionality 
    using close(2) and dup() would be subject to race conditions, whereby newfd might 
    be reused between the two steps.  Such reuse could happen because the main program
    is interrupted by a signal handler that allocates a file descriptor, or because a 
    parallel thread allocates a file descriptor.