1. 检测多个数据输入，`select`系统调用

    ```c
    #include <sys/select.h>
    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    ```

    准备一个`fd_set`，将你要监控的文件描述符插入进去，然后将这些文件描述符中的最
    大值再`+1`传给`nfds`参数，`writefds`和`exceptfds`传`NULL`，准备一个时间结构体，
    将指针传给`timeout`，这样`select`就会在`timeout`所指定的时间内对被插入到`readfds`
    中的数据源进行监视。返回`-1`意味出错，返回0或正数表示有数据的数据源的数量。

    然后就可以用`FD_ISSET(specific_fd)`来判断`specific_fd`这个数据源是否有数据(当然specific_fd)
    必须在`readfds`中哈

    ```c
    // demo code
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(1, &fds);
    FD_SET(4, &fds);
    // 在2s内检查数据
    struct timeval timeout;
    timeval.tv_sec = 2;
    timeval.tv_usec = 0;

    int res = select(5, &fds, NULL, NULL, &timeout);
    
    if (res == -1 ) {
        // error
    } else if (res == 0) {
        // no msg
    } else {
        // we got a msg
        if (FD_ISSET(1)) {
            // have msg from fd 1
            // read from 1
        }
        if (FD_ISSET(4)) {
            // have msg from fd 4
            // read from 4
        }
    }
    ```
    > 需要格外地注意，在linux中`select`调用后，会修改`timeout`参数，所以如果你要
    循环多次地调用`select`，注意在每一次调用时将`timeout`reset下

2. `select`和`poll`，两者的功能是差不多的。`select`是Berkeley研制出来的，而`poll`
   则是贝尔实验室的成果。

3. 命名管道(named pipe)(fifo)

   普通的管道只允许在父子进程或者是兄弟进程之间进行通讯，而命名管道则允许在不相关
   的进程间进行通讯，而且还可以独立于进程存在

   使用`mkfifo`函数来创建命名管道，

    ```c
    int mkfifo(const char *pathname, mode_t mode);
    ```

    命名管道的标识是靠`pathname`这个文件名的，这也是命名管道可以脱离于进程而独立
    存在的原因

    2进程若要通讯的话，只需对这个`pathname`打开进行读写就可以了

    ```c
    // 会阻塞进程，直到有进程进行写
    open(pathname, O_RDONLY);
    // 会阻塞进程，直到有进程进行读
    open(pathname, O_WRONLY);
    ```

    同样的，写的进程只有将文件关闭读的进程才会收到EOF


4. 在读和写不超过`PIPE_BUF`大小的情况下，`read`和`write`是元子操作

5. 共享内存

   同一个系统里的两个进程通过使用共享的内存段来交换数据，共享的内存段是用户内存
   的一部分。每一个进程都有一个指向此内存段的指针。共享内存相对于进程而言，就像
   是全局变量相对于线程一样

   共享内存的一些基本概念:
   1. 共享内存段在内存中不依赖于进程的存在而存在
   2. 共享内存段有自己的名字，成为关键字(key)
   3. key是一个整形数
   4. 共享内存拥有自己的拥有着以及权限位
   5. 进程可以连接到某共享内存段，并且获得指向此段内存的指针

   共享内存是有权限的，这点和文件比较类似

   > 文件，命名管道，共享内存以及UNIX domain的socket都有着UNIX的标准权限系统，
   而internet socket则不行


6. 竞态条件

   共享文件和共享内存的访问不是由内核进行管理的，由此可能会发生读者写者问题。在写
   方没有写完时，读方就进行了读操作，则惨了。

7. 对于文件的读写者问题，根据读者或写者占据共享资源的情况，有两种文件锁。一种给
   读者，告诉其他进程，有进程在读此文件，其他进程若想写此文件，则要等待。另一个
   给写者，告诉其他进程，有进程在写此文件，其他进程若想读此文件，则要等待
