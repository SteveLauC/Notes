#### Ch10: Time

1. The UNIX Epoch: January 1, 1970, is approximately the date (November 3, 1971)
   when the UNIX system came into being.

2. UNIX system use `time_t` to represent the seconds since `Epoch`, on 32-bit
   systems, `time_t` is an alias to `i32`, so the latest time this can represent
   is `03:14:07 UTC on 19 January 2038`, this is called `Year 2038 problem`.

   On 64-bit systems, this is fine as `time_t` is an alias to `i64`.

   ```rust
   pub type time_t = i64;
   ```

   > Such time represented in an absolute seconds elapsed since EPOCH is called
   > calendar time.

3. use `gettimeofday(2)` and `settimeofday(2)` to get or set calendar time

   ```c
   #include <sys/time.h>
   
   int gettimeofday(struct timeval *restrict tv, struct timezone *restrict tz);
   int settimeofday(const struct timeval *tv, const struct timezone *tz);
   ```


   These two syscalls are used to get or set time as well as timezone (not anymore).

   NOTE: argument `tz` is **obsolete** and always should be specified as `NULL`.

   ```c
   struct timeval {
       time_t      tv_sec;     /* seconds since 00:00:00, 1 Jan 1970 UTC */
       suseconds_t tv_usec;    /* microseconds */
   };

   // obsolete
   struct timezone {
       int tz_minuteswest;     /* minutes west of Greenwich */
       int tz_dsttime;         /* type of DST correction */
   };
   ```

   > Order of magnitude (time):
   >
   > (1) second = (10^3) milisecond = (10^6) microsecond = (10^9) nanosecond
   >
   > [wikipedia](https://simple.wikipedia.org/wiki/Orders_of_magnitude_(time))

   > And even though `timeval` has `microsec` precision, whether it is supported
   > is hardware dependent.

4. use `time(2)` to fetch calendar time
   
   ```c
   #include <time.h>

   time_t time(time_t *tloc);
   ```

   Returns the seconds since Epoch on success, `-1` on error.
   If `tloc` is not `NULL`, then the result is also stored in the memory pointed
   by `tloc`.

   The **ONLY** error that could happen is that `tloc` points to an invalid address.
   > EFAULT: tloc points outside your accessible address space (but see BUGS).

   So if you use `time(2)` like this, no error will happen at all:

   ```c
   time_t seconds_since_epoch = time(NULL);
   assert(seconds_since_epoch != -1);
   ```

   > The functionality of `time(2)` and `gettimeofday(2)` overlaps since `time(2)`
   > is provided by early UNIX implemention, and `gettimeofday(2)` is derived
   > from BSD.

5. use `ctime(3)` to convert `time_t` to printable form.
   
   ```c
   #include <time.h>

   // return statically allocated string terminated by '\0' and NUL.
   char *ctime(const time_t *timep);
   // put result in memory pointed by `buf`, and return `buf`.
   char *ctime_r(const time_t *restrict timep, char *restrict buf);
   ```

   These syscalls will handle `timezone` and `DST` for us automatically.

   ```c
   #include <string.h>
   #include <assert.h>
   #include <stdio.h>
   #include <time.h>
   
   int main(void)
   {
       time_t now = time(NULL);
       char buf[100];
       assert(ctime_r(&now, buf) != NULL);
       // remove the tailing newline
       long len = strlen(buf);
       buf[len - 2] = '\0';
       printf("%s\n", buf);
       return 0;
   }
   ```
   ```shell
   $ gccs main.c && ./a.out
   Thu Sep  1 07:24:26 202
   ```

6. use `gmtime(3)` and `localtime(3)` to convert `time_t` to broken-down time.

   [What is broken-down time](https://www.gnu.org/software/libc/manual/html_node/Broken_002ddown-Time.html)

   ```c
   struct tm {
       int tm_sec;    /* Seconds (0-60) can be 60 to account for the leap seconds */
       int tm_min;    /* Minutes (0-59) */
       int tm_hour;   /* Hours (0-23) */
       int tm_mday;   /* Day of the month (1-31) */
       int tm_mon;    /* Month (0-11) */
       int tm_year;   /* Year - 1900 */
       int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
       int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
       int tm_isdst;  /* Daylight saving time */
   };
   ``` 

   When `_BSD_SOURCE` is defined, this struct also includes two additional fields,
   This is a BSD extension, present in 4.3BSD-Reno.

   ```
   long tm_gmtoff;           /* Seconds east of UTC */
   const char *tm_zone;      /* Timezone abbreviation */
   ```

   ```c
   struct tm *gmtime(const time_t *timep);
   struct tm *gmtime_r(const time_t *restrict timep, struct tm *restrict result);

   struct tm *localtime(const time_t *timep);
   struct tm *localtime_r(const time_t *restrict timep, struct tm *restrict result);
   ```

   Diff between `gmtime(3)` and `localtime(3)`:

   * The gmtime() function converts the calendar time timep to broken-down time
     representation, expressed in **Coordinated Universal Time (UTC)**.

     > `gm` means `Greenwich Mean Time`
     > 
     > [Diff between `GMT` and `UTC`](https://stackoverflow.com/questions/48942916/what-is-the-difference-between-utc-and-gmt)
     > 
     > I didn't get it, but seems these two things have the same time.


   * The  localtime()  function converts the calendar time timep to broken-down
     time representation, expressed **relative to the user's specified timezone**.


   ```c
   #include <string.h>
   #include <stdio.h>
   #include <time.h>
   
   int main(void)
   {
           time_t now = time(NULL);
           struct tm buf1;
           struct tm buf2;
   
           gmtime_r(&now, &buf1);
           localtime_r(&now, &buf2);
   
           printf("gmtime_r: day: %d hour: %d\n", buf1.tm_mday, buf1.tm_hour);
           printf("localtime_r: day: %d hour: %d\n", buf2.tm_mday, buf2.tm_hour);
           return 0;
   }
   ```
   ```shell
   $ date
   Thu Sep  1 07:57:02 AM CST 2022
   
   $ gccs main.c && ./a.out
   gmtime_r: day: 31 hour: 23
   localtime_r: day: 1 hour: 7
   ```

7. use `mktime(3)` to convert *local* broken-down time to calendar time:

   ```c
   #include <time.h>

   time_t mktime(struct tm *tm);
   ```

   This function ignores the `tm_wday` and `tm_yday` fields

   > If you pass `struct tm` return by `gmtime(3)` to `mktime(3)`, `mktime(3)`
   > will return an erroneous value.

8. use `asctime(3)` to convert Broken-down time to printable form
  
   ```c
   #include <time.h>

   char *asctime(const struct tm *tm);
   char *asctime_r(const struct tm *restrict tm, char *restrict buf);
   ``` 
   
   ```c
   #include <stdio.h>
   #include <time.h>
   
   int main(void)
   {
           time_t now = time(NULL);
           struct tm buf1;
           struct tm buf2;
   
           gmtime_r(&now, &buf1);
           localtime_r(&now, &buf2);
   
           printf("%s\n", asctime(&buf1));
           printf("%s\n", asctime(&buf2));
           printf("%s\n", ctime(&now));
           return 0;
   }
   ```
   ```shell
   $ gccs main.c && ./a.out
   Thu Sep  1 01:57:57 2022
   
   Thu Sep  1 09:57:57 2022
   
   Thu Sep  1 09:57:57 2022
   ```

9. use `strftime(3)` to convert `broken-down time` to printable form with
   **more precision**

   ```c
   #include <time.h>

   size_t strftime(char *restrict s, size_t max, 
                   const char *restrict format, 
		   const struct tm *restrict tm);
   ```

10. use `strptime(3)` to convert `printable form` to `broken-down time`

    > reverse of `strftime(3)`

    ```c
    #define _XOPEN_SOURCE       /* See feature_test_macros(7) */
    #include <time.h>

    char *strptime(const char *restrict s, 
                   const char *restrict format,
		   struct tm *restrict tm);
    ```

    The glibc implementation of `strptime(3)` will not modify those fields of the
    `tm` structure that are not initialized by specifiers in `format`. This is not
    portable, so we should ensure that all the fields of `tm` are initialzed validly
    in portable programs.

    `tm_isdst` field is not set.

11. use `setlocale(3)` to get or set locale setting
