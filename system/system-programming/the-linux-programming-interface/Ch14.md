#### Ch14: File Systems

> 1. device speical file
> 2. disk and partition
> 3. file system
> 4. I-node
> 5. VFS

1. what is `device special file`
  
   Just a file representing a real or virtual device. For each device, there are 
   two numbers:
   1. major ID number: identifies the general class of the device, and is used to
      look up the appropriate drivers for this type of device.
   2. minor ID number: The minor ID number is used to uniquely identify a specific
      device within a device class.

   ```shell
   $ cd /dev/input
   $ ls -l
   total 0
   drwxr-xr-x. 2 root root     140 Sep 17 07:06 by-id
   drwxr-xr-x. 2 root root     160 Sep 17 07:06 by-path
   crw-rw----. 1 root input 13, 64 Sep 17 07:06 event0
   crw-rw----. 1 root input 13, 65 Sep 17 07:06 event1
   crw-rw----. 1 root input 13, 74 Sep 17 07:06 event10
   crw-rw----. 1 root input 13, 75 Sep 17 07:06 event11
   crw-rw----. 1 root input 13, 76 Sep 17 07:06 event12
   crw-rw----. 1 root input 13, 66 Sep 17 07:06 event2
   crw-rw----. 1 root input 13, 67 Sep 17 07:06 event3
   crw-rw----. 1 root input 13, 68 Sep 17 07:06 event4
   crw-rw----. 1 root input 13, 69 Sep 17 07:06 event5
   crw-rw----. 1 root input 13, 70 Sep 17 07:06 event6
   crw-rw----. 1 root input 13, 71 Sep 17 07:06 event7
   crw-rw----. 1 root input 13, 72 Sep 17 07:06 event8
   crw-rw----. 1 root input 13, 73 Sep 17 07:06 event9
   crw-rw----. 1 root input 13, 63 Sep 17 07:06 mice
   crw-rw----. 1 root input 13, 32 Sep 17 07:06 mouse0
   crw-rw----. 1 root input 13, 33 Sep 17 07:06 mouse1
   ```

   You can see that all device files under `/dev/input` have the same major ID
   number, meaning they belong to the same class. But they do have different
   minor ID numbers as they are different devices.

   > On Linux 2.4 and eariler, the total number for the devices are limited by
   > the fact that `major ID number` and `minor ID number` are all represented
   > in a 8-bit number. This was eased in kernel 2.6 as they switched to more
   > bits (12 and 20 respectively).

   How to create a `device special file`?

   You can do this through `mknod(1)` or `mknod(2)`.
   > Actually, you can create regular file (which will be  created  empty),  
   > *character  special  file, block special file*, FIFO (named pipe), or 
   > UNIX domain socket throught this.


2. each partition is treated as a separate device residing under `/dev`

   One can use `fdisk` command to operate on partitions.

   The Linux-specific file `/proc/partitions` lists major and minor device number,
   number of blocks and name.

   ```
   major minor  #blocks  name
   
    259        0  488386584 nvme0n1
    259        1     614400 nvme0n1p1
    259        2    1048576 nvme0n1p2
    259        3  486722560 nvme0n1p3
    252        0    8388608 zram0
   ```

   A partition may contain any type of information, but usually contains one
   of the following:
   * a file system
   * a data area (accessed as raw-mode device, typicall used by a DBMS)
   * a swap area

3. Linux supports a variety of file systems. To view them:
  
   ```shell
   $ cat /proc/filesystems
   nodev        sysfs
   nodev        tmpfs
   nodev        bdev
   nodev        proc
   nodev        cgroup
   nodev        cgroup2
   nodev        cpuset
   nodev        devtmpfs
   nodev        configfs
   nodev        debugfs
   nodev        tracefs
   nodev        securityfs
   nodev        sockfs
   nodev        bpf
   nodev        pipefs
   nodev        ramfs
   nodev        hugetlbfs
   nodev        devpts
    ext3
    ext2
    ext4
   nodev        autofs
   nodev        efivarfs
   nodev        mqueue
   nodev        selinuxfs
   nodev        binder
   nodev        resctrl
    btrfs
   nodev        pstore
    fuseblk
   nodev        fuse
   nodev        fusectl
    vfat
   nodev        rpc_pipefs
   ```

4. FUSE (file system in userspace)

   Allows the non-priviledged user to create their own file system without editing
   the kernel code.

   [homepage](https://github.com/libfuse/libfuse)

5. file system structure

   ![diagram](https://github.com/SteveLauC/pic/blob/main/photo_2022-09-21_10-47-52.jpg)

   * boot block: This is always the first block in a file system. The boot block
     is for the OS. Though there is only one boot block that will be used by the
     OS, all files systems contain a boot block.

   * super block: contains the following information
     * the size of the i-node table
     * logical block size (file system block size)
     * the size of file system in logical blocks

   * i-node table (i-list): each file or directory will has a unique entry in 
     this table. (i stands for *index*)

   * Data blocks: data that forms the files or directories
     

6. i-node entry

   A i-node table contains a lots of i-node entries (each for a file), and each 
   i-node entry is identified by a unique number called inode number or i-number.

   What a i-node entry contains:
   1. File type
   2. UID
   3. GID
   4. Access Permission
   5. Timestamps: access time (last read), change time (last write to metadata), 
      modification time (last write to file contents)
   6. Number of hard links
   7. Size of the file in bytes
   8. Number of allocated blocks (block size = 512 bytes)
   9. Pointer to data blocks.

7. Pointers to data blocks in i-node entry

   Take ext2 as an example:
   
   ![diagram](https://github.com/SteveLauC/pic/blob/main/photo_2022-09-21_12-32-29.jpg)

   Under ext2, each i-node entry has 15 pointers. The first 12 are direct pointers.
   Number 12 (the thirteenth) is an indirect pointer pointing to a block of pointers. 
   Number 13 is a double-indirect pointer pointing to an indirect pointer.
   Number 14 is a triple-indirect pointer.

   Such a design has the following advantages:
   1. Small files can be accessed rapidly because 12 direct pointers are sufficient
      for them.
   2. It allows i-node entry to be a fixed size.
   3. File can reside on the disk incontiguously.
   4. Data can be randomly accessed through `lseek(2)` (just calculate which 
      pointer to follow)
