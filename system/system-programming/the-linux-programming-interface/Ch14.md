#### Ch14: File Systems

> 1. concept: device speical file
> 2. concept: disk and partition
> 3. concept: file system in userspace (FUSE)
> 4. concept: file system and its components
> 5. concept: I-node
> 6. concept: VFS (an abstraction layer)
> 7. the advantage of journaling file systems: consistency check
> 8. list all the mount points
> 9. `mount(2)` and `unmount(2)` syscall

1. what is `device special file`
  
   Just a file representing a real or virtual device. For each device, there are 
   two numbers:
   1. major ID number: identifies the general class of the device, and is used to
      look up the appropriate drivers for this type of device.
   2. minor ID number: The minor ID number is used to uniquely identify a specific
      device within a device class.

   ```shell
   $ cd /dev/input
   $ ls -l
   total 0
   drwxr-xr-x. 2 root root     140 Sep 17 07:06 by-id
   drwxr-xr-x. 2 root root     160 Sep 17 07:06 by-path
   crw-rw----. 1 root input 13, 64 Sep 17 07:06 event0
   crw-rw----. 1 root input 13, 65 Sep 17 07:06 event1
   crw-rw----. 1 root input 13, 74 Sep 17 07:06 event10
   crw-rw----. 1 root input 13, 75 Sep 17 07:06 event11
   crw-rw----. 1 root input 13, 76 Sep 17 07:06 event12
   crw-rw----. 1 root input 13, 66 Sep 17 07:06 event2
   crw-rw----. 1 root input 13, 67 Sep 17 07:06 event3
   crw-rw----. 1 root input 13, 68 Sep 17 07:06 event4
   crw-rw----. 1 root input 13, 69 Sep 17 07:06 event5
   crw-rw----. 1 root input 13, 70 Sep 17 07:06 event6
   crw-rw----. 1 root input 13, 71 Sep 17 07:06 event7
   crw-rw----. 1 root input 13, 72 Sep 17 07:06 event8
   crw-rw----. 1 root input 13, 73 Sep 17 07:06 event9
   crw-rw----. 1 root input 13, 63 Sep 17 07:06 mice
   crw-rw----. 1 root input 13, 32 Sep 17 07:06 mouse0
   crw-rw----. 1 root input 13, 33 Sep 17 07:06 mouse1
   ```

   You can see that all device files under `/dev/input` have the same major ID
   number, meaning they belong to the same class. But they do have different
   minor ID numbers as they are different devices.

   > On Linux 2.4 and eariler, the total number for the devices are limited by
   > the fact that `major ID number` and `minor ID number` are all represented
   > in a 8-bit number. This was eased in kernel 2.6 as they switched to more
   > bits (12 and 20 respectively).

   How to create a `device special file`?

   You can do this through `mknod(1)` or `mknod(2)`.
   > Actually, you can create regular file (which will be  created  empty),  
   > *character  special  file, block special file*, FIFO (named pipe), or 
   > UNIX domain socket throught this.


2. each partition is treated as a separate device residing under `/dev`

   One can use `fdisk` command to operate on partitions.

   The Linux-specific file `/proc/partitions` lists major and minor device number,
   number of blocks and name.

   ```
   major minor  #blocks  name
   
    259        0  488386584 nvme0n1
    259        1     614400 nvme0n1p1
    259        2    1048576 nvme0n1p2
    259        3  486722560 nvme0n1p3
    252        0    8388608 zram0
   ```

   A partition may contain any type of information, but usually contains one
   of the following:
   * a file system
   * a data area (accessed as raw-mode device, typicall used by a DBMS)
   * a swap area

3. Linux supports a variety of file systems. To view them:
  
   ```shell
   $ cat /proc/filesystems
   nodev        sysfs
   nodev        tmpfs
   nodev        bdev
   nodev        proc
   nodev        cgroup
   nodev        cgroup2
   nodev        cpuset
   nodev        devtmpfs
   nodev        configfs
   nodev        debugfs
   nodev        tracefs
   nodev        securityfs
   nodev        sockfs
   nodev        bpf
   nodev        pipefs
   nodev        ramfs
   nodev        hugetlbfs
   nodev        devpts
    ext3
    ext2
    ext4
   nodev        autofs
   nodev        efivarfs
   nodev        mqueue
   nodev        selinuxfs
   nodev        binder
   nodev        resctrl
    btrfs
   nodev        pstore
    fuseblk
   nodev        fuse
   nodev        fusectl
    vfat
   nodev        rpc_pipefs
   ```

4. FUSE (file system in userspace)

   Allows the non-priviledged user to create their own file system without editing
   the kernel code.

   [homepage](https://github.com/libfuse/libfuse)

5. file system structure

   ![diagram](https://github.com/SteveLauC/pic/blob/main/photo_2022-09-21_10-47-52.jpg)

   * boot block: This is always the first block in a file system. The boot block
     is for the OS. Though there is only one boot block that will be used by the
     OS, all files systems contain a boot block.

   * super block: contains the following information
     * the size of the i-node table
     * logical block size (file system block size)
     * the size of file system in logical blocks

   * i-node table (i-list): each file or directory will has a unique entry in 
     this table. (i stands for *index*)

   * Data blocks: data that forms the files or directories
     

6. i-node entry

   A i-node table contains a lots of i-node entries (each for a file), and each 
   i-node entry is identified by a unique number called inode number or i-number.

   What a i-node entry contains:
   1. File type
   2. UID
   3. GID
   4. Access Permission
   5. Timestamps: access time (last read, atime), change time (last write to 
      metadata, ctime), modification time (last write to file contents, mtime)
   6. Number of hard links
   7. Size of the file in bytes
   8. Number of allocated blocks (block size = 512 bytes)
   9. Pointer to data blocks.

7. Pointers to data blocks in i-node entry

   Take ext2 as an example:
   
   ![diagram](https://github.com/SteveLauC/pic/blob/main/photo_2022-09-21_12-32-29.jpg)

   Under ext2, each i-node entry has 15 pointers. The first 12 are direct pointers.
   Number 12 (the thirteenth) is an indirect pointer pointing to a block of pointers. 
   Number 13 is a double-indirect pointer pointing to an indirect pointer.
   Number 14 is a triple-indirect pointer.

   Such a design has the following advantages:
   1. Small files can be accessed rapidly because 12 direct pointers are sufficient
      for them.
   2. It allows i-node entry to be a fixed size.
   3. File can reside on the disk incontiguously.
   4. Data can be randomly accessed through `lseek(2)` (just calculate which 
      pointer to follow)

8. Virtual File System (VFS) (or Virtual File Switch)

   Different file systems differ in its detailed implementations, VFS is an 
   abstraction layer to hide such differences.

   ![diagram](https://github.com/SteveLauC/pic/blob/main/photo_2022-09-23_09-26-20.jpg)

   This is actually a collection of APIs, such as:
   `open/read/write/mount/lseek/close/truncate/stat/unmount/mmap/mkdir/link/unlink`, etc.

   > Some file system may not support all the APIs requested by VFS (e.g., 
   > Microsoft VFAT does not support symbolic links). In this case, then
   > underlying file system will return an error to VFS, and VFS will transfer
   > this to the Application.

9. The advantage of journaling file systems

   Normally, a consistency check is performed on reboot in order to ensure
   the integrity of the file system. This should be done because, at the 
   time of the system crash, a file update may be partially completed.

   Such a consistency check needs to check the whole file system, which is
   extermely time-consuming for traditional UNIX file systems (e.g, ext2).

   But this task is super easy for journaling file system as a **log** will be
   performed **before** the time of updating. Due to the log, a consistency 
   check can be easily executed by checking logs.

10. list all the mount points 
    
    1. using `mount(8)`

       ```shell
       $ mount
       /dev/sda6 on / type ext4(rw)
       proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
       sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
       devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,nr_inodes=1048576,mode=755,inode64)
       securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
       tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
       devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
       tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=3151336k,nr_inodes=819200,mode=755,inode64)
       ...
       ```

    2. read from the Linux-specific file `/proc/mounts`

       ```shell
       $ ls /proc/mounts
       Permissions Links Size User Group Date Modified Name
       lrwxrwxrwx@     1   11 root root  23 Sep 07:12  /proc/mounts -> self/mounts

       $ cat /proc/mounts
       proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
       sysfs /sys sysfs rw,seclabel,nosuid,nodev,noexec,relatime 0 0
       devtmpfs /dev devtmpfs rw,seclabel,nosuid,size=4096k,nr_inodes=1048576,mode=755,inode64 0 0
       securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0
       tmpfs /dev/shm tmpfs rw,seclabel,nosuid,nodev,inode64 0 0
       devpts /dev/pts devpts rw,seclabel,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0
       tmpfs /run tmpfs rw,seclabel,nosuid,nodev,size=3151336k,nr_inodes=819200,mode=755,inode64 0 0
       ...
       ```

       > The reason why `/proc/mounts` is a soft link is that Linux introduces
       > [per-process mount namespace](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html)

       > For the file format, see note 12.

    3. read from `/etc/mtab`

       This file is maintained by `mount(8)` and `unmount(8)` and silimar to 
       `/proc/mounts` but more detailed.

       ```shell
       $ cat /etc/mtab
       proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
       sysfs /sys sysfs rw,seclabel,nosuid,nodev,noexec,relatime 0 0
       devtmpfs /dev devtmpfs rw,seclabel,nosuid,size=4096k,nr_inodes=1048576,mode=755,inode64 0 0
       securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0
       tmpfs /dev/shm tmpfs rw,seclabel,nosuid,nodev,inode64 0 0
       devpts /dev/pts devpts rw,seclabel,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0
       tmpfs /run tmpfs rw,seclabel,nosuid,nodev,size=3151336k,nr_inodes=819200,mode=755,inode64 0 0
       ...
       ```

       > NOTE: `mount(2)` and `unmount(2)` will not edit this file so it may be
       > inaccurate if the caller forget to update it.

       > For the file format, see note 12.

11. `/etc/fstab`
  
    This file contains all the descriptions of  available file systems on a system.
    It should be edited manually by the system administrator. `mount(8)`, `unmount(8)`
    and `fsck(8)` relies on it.

    ```shell
    $ cat /etc/fstab
    #
    # /etc/fstab
    # Created by anaconda on Wed Aug 24 18:04:46 2022
    #
    # Accessible filesystems, by reference, are maintained under '/dev/disk/'.
    # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
    #
    # After editing this file, run 'systemctl daemon-reload' to update systemd
    # units generated from this file.
    #
    UUID=6d21f1be-9640-4f47-8d22-847269e24fc6 /                       btrfs   subvol=root,compress=zstd:1 0 0
    UUID=6aa0611f-8869-468e-acf4-acf0dfd66d1f /boot                   ext4    defaults        1 2
    UUID=0296-E38B          /boot/efi               vfat    umask=0077,shortname=winnt 0 2
    UUID=6d21f1be-9640-4f47-8d22-847269e24fc6 /home                   btrfs   subvol=home,compress=zstd:1 0 0
    ```

    > functions like `getfsent(3)` and `getmntent(3)` can be used to sequencely
    > scan `/etc/fstab`

    > For the file format, see note 12.

12. file format of `/proc/mount`, `/etc/mtab` and `/etc/fstab`

    ```
    /dev/sda9 /boot ext3 rw 0 0
    ```

    * device special file
    * mount point
    * file system type
    * mount flags: `rw` in the above example indicates that the file system was 
      mounted read-write.
    * A number used to control the operation of file system backups by `dump(8)`.
      This field and the next are used only by `/etc/fstab`. For `/proc/mounts`
      and `/etc/mtab`, these fields are always `0`.
    * A number used to control the order in which `fsck(8)` checks file systems
      at boot.

    For detailed format, see [man 5 fstab](https://man7.org/linux/man-pages/man5/fstab.5.html)

13. mount a file system using `mount(2)`
    
    ```c
    #include <sys/mount.h>

    int mount(const char *source, const char *target,
              const char *filesystemtype, unsigned long mountflags,
              const void *data);
    ```

    Arguments: 
    * source: device special file
    * target: target directory
    * filesystemtype: string representing a file-system type
    * mountflags: mount option
    * data: buffer whose contents will be interpreted by the underlying file system.

    Some Mount flags: (For full information, see 
    [man 2 mount](https://man7.org/linux/man-pages/man2/mount.2.html) and TLPI 
    page: 264-267)

    * MS_BIND: Create a bind mount. If this flag is present, `fstype`, `mountflags`
      and `data` are ignored.

      > [what is bind mount](https://unix.stackexchange.com/q/198590/498440)

    * MS_DIRSYNC: make directory updates synchronous. Similar to `O_SYNC` of 
      `open(2)` but just for direcoties.
   
    * MS_SYNCHRONOUS: make data and directory modifications synchronous.

    * MS_NOATIME: don't update atime in this file system.
      
      > This can improve the performance significantly in some applications.

    * MS_NOEXEC: don't allow binaries or scripts to be executed from this file
      system.

    * MS_NOSUID: Disable set-UID and set-GID programs in this fs.
      > Useful if you don't trust the contents of an external disk.

    * MS_RDONLY: mount the file system read-only.
