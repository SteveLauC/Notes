#### Ch13: File I/O Buffering

> 1. kernel buffer cache and libc buffer
> 2. library functions (setvbuf/setbuf/setbuffer/setlinebuf) used to modify the
     buffering mode of stream buffer (libc buffer)
> 3. library function to flush the buffer (flush(3))
> 4. syscalls for controlling kernel buffer
> 5. direct I/O, which is useful in database storage engine.

1. kernel `buffer cache`
   
   When performing disk operation, the kernel maintains a memory called 
   `buffer cache` to cache the bytes stream in order to reduce the number
   of disk I/O.

   For example, in the following statement, we are transferring 5 bytes to
   the `buffer cache` rather than directly writing them to the `disk file`.
   Later, when appropricate, the disk will flush these bytes to disk.
   (And therefore, we say disk operation is *not synchronized*)

   ```c
   write(fd, "hello", 5);
   ```

   And for input, the kernel will `prefetch` data from disk to the `buffer cache`
   so that in the subsequent `read`, we can directly read from the `buffer` instead
   of performing disk operation.

   ```c
   read(fd, buf, 5);
   ```

   > To be precise, since Kernel 2.14, Linux no longer maintains a separate
   > `buffer cache`. Instead, file I/O buffers are included in the page cache.
   > But we still use the word `buffer cache` as this is the general terminology
   > in UNIX world.

2. `write(2)`

   ```c
   fd = open(file, O_WDONLY);
   write(fd, "hello", 5);
   ``` 

   The above `write(2)` will return immediately after the `"hello"` is transferred
   to the kernel `buffer cache`. (No disk output performed when `write(2)` returns
   **NOT SYNCHRONOUS**)

   But if we use `O_SYNC` flag, then `write(2)` will return only when the data is
   writen to the disk.

   > [Ch4 Note 5 flag arguments of open(2)](https://github.com/SteveLauC/Notes/blob/main/system/system-programming/the-linux-programming-interface/Ch4.md)

3. impact of `buffer size` on the performance of I/O 

   `buffer cache` is used to decrease the amount of `disk I/O`, but in our source 
   code, we can empoly a bigger buffer to reduce the number of syscalls.

   ```rust
   /// copy.rs
   /// usage: copy source destination

    use std::env::args;
    use std::fs::{File, OpenOptions};
    use std::io::{Read, Write};
    use std::os::unix::fs::OpenOptionsExt;
    use std::process::exit;
    
    const BUF_SIZE: usize = 1024;
    
    fn main() {
        let av: Vec<String> = args().collect();
        if av.len() != 3 {
            eprintln!("usage: {} old-file new-file", av[0]);
        }
    
        let mut input_file: File =
            File::open(av[1].as_str()).expect(format!("opening file: {}", av[1]).as_str());
        let mut output_file: File = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o666)
            .open(av[2].as_str())
            .expect(format!("opening file: {}", av[2]).as_str());
    
        let mut buf: [u8; BUF_SIZE] = [0; BUF_SIZE];
        while let Ok(num_read) = input_file.read(&mut buf) {
            if num_read > 0 {
                let wrrite_res: Result<usize, _> = output_file.write(&buf[..num_read]);
                if wrrite_res.is_err() || wrrite_res.unwrap() != num_read {
                    eprintln!("could't write whole buffer");
                    exit(1);
                }
            }
    
            if num_read == 0 {
                break;
            }
        }
   }
   ```

   In the above program, we use a buffer of size `1024`, we can try different 
   values to measure the time consumed to copy a big file:

   Here we have two executables with bufsize of `1 bytes` and `1024 bytes` 
   respectively, and we try to copy `log` using these two binaries:

   ```shell
   $ l
   Permissions Size User  Group Date Modified Name
   .rwxr-xr-x@ 4.2M steve steve 13 Sep 10:07  big-buf-cp
   .rw-r--r--@  20M steve steve 13 Sep 11:12  log
   .rwxr-xr-x@ 4.2M steve steve 13 Sep 10:04  small-buf-cp

   $ /usr/bin/time -p ./small-buf-cp log log1
   real 34.30
   user 2.03
   sys 32.23
   
   $ /usr/bin/time -p ./big-buf-cp log log1
   real 0.07
   user 0.00
   sys 0.05
   ```

   We inspect the `program time`, which is the sum of `user time` and `sys time`.
   Notably, you can see the big difference between the `sys time` of these two 
   experiments. Well, `sys time` is the time consumed in `kernel space`, which
   is used for `preparing for syscalls` and `transferring data between user 
   space and kernel space`. That's basically the overhead of calling `read(2)` 
   and `write(2)`.

   > refer to [Ch3 note1: the process of syscall](https://github.com/SteveLauC/Notes/blob/main/system/system-programming/the-linux-programming-interface/Ch3.md)


   The size of buffer can have a big impact on the performance.


4. libc buffering

   > This is exactly what we did in Note 3, using a bigger buffer to decrease
   > the number of syscalls except this finished by the standard library 
   > developer.

   These are three types of buffering modes:

   1. unbuffered
   2. block buffered
   3. line buffered

   Any stream pointing to a regular file is `block buffered`. `stdin` and `stdout`
   are `line buffered` when they refer to the terminal. `stderr` is `unbuffered`.
   
   ```c
   #include <stdio.h>

   int setvbuf(FILE *restrict stream, char *restrict buf, int mode, size_t size);

   void setbuf(FILE *restrict stream, char *restrict buf);
   void setbuffer(FILE *restrict stream, char *restrict buf, size_t size);
   void setlinebuf(FILE *stream);
   ```

   The above lib functions can be used to modify the mode of buffering.

   `setvbuf(3)` is the general one and the other functions are based on all 
   `setvbuf(3)`. The `stream` argument identifies the stream to be modified.
   And if you wanna modify the mode, **do it after stream is open and 
   before any I/O operation has been performed on this stream**, this modification 
   will effect all the subsequent I/O functions performed on this
   stream.

   The `mode` argument can be set as:
   1. `_IONBF`: unbuffered
   2. `_IOFBF`: full (block) buffered
   3. `_IOLBF`: line buffered 

   The `buf` and `size` argument can be used in two ways:

   1. If `buf` is non-NULL, then it should points to a block of static or
      heap-allocated memory with size of `size`. (Do NOT allocate it on the
      stack).
   2. If `buf` is NULL, and if `mode` is set to either `_IOFBF` or `_IOLBF`,
      then libc will automatically allocate memory for you (How much space
      will be allocated and will `size` argument to be used to determine the
      size in this process? This is **implementation defined**!. In glibc,
      size is simply ignored). If `mode` is `_IONBF`, then no allocation is
      needed and `size` is ignored.

   
   `setbuf(FILE *restrict stream, char *restrict buf)` is just 
   `setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ)`. You should alloate
   buffer yourself and the size of this buffer should at least be `BUFSIZ`.

   `setbuffer(FILE *restrict stream, char *restrict buf, size_t size)` is just
   `setvbuf(stream, buf, buf ? _IOFBF : _IONBF, **size**)`. The only difference
   between `setbuf` and `setbuffer` is that you can control the buffer size
   rather than using `BUFSIZ` in the latter.

   `setlinebuf(FILE *stream)` is `setvbuf(stream, NULL, _IOLBF, 0)`.

   Just like `setvbuf`, all these 3 functions should be used before any I/O
   operation has been performed on `stream`. And the memory allcoated should
   be static or heap-allocated.


5. flush a stdio buffer
   
   ```c
   #include <stdio.h>

   int fflush(FILE *stream);
   ```

   If the stream argument is NULL, fflush() flushes *all* open output streams.

   If `stream` points to input stream associated with `seekable` files (not pipe
   orr terminal), then the contents of buffer will be discarded.

   The buffer will be automatically flushed when the stream is closed.

   In many ligc implementation (including glibc), stdout will be flushed when 
   we read from stdin. Rust std does not follow this.

6. 
