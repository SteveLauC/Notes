1. selection sort: swap the ith smallest item with s[i]

   ```rust
   fn selection_sort<T: PartialOrd>(s: &mut [T]) {
       let len: usize = s.len();
       for i_idx in 0..len {
           let mut min_idx: usize = i_idx;
           for j_idx in (i_idx + 1)..len {
               if s[j_idx] < s[min_idx] {
                   min_idx = j_idx;
               }
           }
           s.swap(min_idx, i_idx);
       }
   }
   ```

   1. analysis 

      * the number of comparision:
     
        When `i_idx`,`j_idx` ranges from `i_idx + 1` to `len`

        |i_idx|range|the number of elements|
        |-----|-----|----------------------|
        |0    |[1, N)| N-1|
        |1    |[2, N)|N-2|
        |..|..|..|
        |N-1|[N-1, N)| 1|
        
        `1+..+(N-1) = (N-1)(1+N-1)/2 = (N^2 - N)/2 ~ N^2/2`

      * the number of exchange: N

   2. there are two unique features of selection sort:

      1. the time complexity is indenpent from the input for the reason that 
      for any kind of input, it will just scan the array to find the minimal value.
     
         If you give a sorted data to the selection sort, you will find it consume
         the same time as the unordered one.
   
      2. It only moves data n times(exclusive to selection sort)

2. insertion sort

   Use a pointer i to iterate over the array from the first element, we assume 
   that all the elements in the left of this pointer are ordered. For the 
   current element pointed to by the pointer, we will try to insert it to 
   our left sorted sub-array.Â  Temporarily store s[i] in a variable key.
   Use another pointer j to iterate over our sorted sub-array from the location 
   of i-1 to 0, if s[j] is bigger than key, move s[j] back by one position using
   s[j+1] = s[j]

   ```rust
   fn insertion_sort<T: PartialOrd + Copy>(s: &mut [T]) {
       for i_idx in 1..s.len() {
           let key: T = s[i_idx];
           let mut j_idx: usize = i_idx - 1;
   
           while s[j_idx] > key {
               s[j_idx + 1] = s[j_idx];
               if j_idx == 0 {
                   break;
               }
               j_idx -= 1;
           }
           s[j_idx] = key;
       }
   }
   ```

   Unlike `selection sort`, the consuming time of insertion sort is decided by
   the input data(note the condition of our while loop is `s[j_idx] > key`)

   1. analysis
